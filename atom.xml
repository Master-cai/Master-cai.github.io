<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Master-cai</title>
  
  <subtitle>[object Object]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.master-cai.xyz/"/>
  <updated>2020-12-19T10:36:39.915Z</updated>
  <id>http://blog.master-cai.xyz/</id>
  
  <author>
    <name>Master-cai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ socket编程小结</title>
    <link href="http://blog.master-cai.xyz/posts/49595.html"/>
    <id>http://blog.master-cai.xyz/posts/49595.html</id>
    <published>2020-12-19T10:23:12.000Z</published>
    <updated>2020-12-19T10:36:39.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-socket编程小结"><a href="#C-socket编程小结" class="headerlink" title="C++ socket编程小结"></a>C++ socket编程小结</h1><p>#随手笔记<br>    最近做毕设的时候涉及到了这方面的知识，也是经过多次遇坑，趁着还有印象记录一下。本篇主要涉及Linux/unix（MAC OS）下的socket编程，win环境下的socket略有不同。</p><h2 id="socket简介"><a href="#socket简介" class="headerlink" title="socket简介"></a>socket简介</h2><p>socket英文直译为“插座，插孔”，可能意思是网络编程就是一个封闭的系统上和外部交互的那个“插孔”吧。但是中文翻译为套接字，感觉不是非常好理解，初学的时候甚至因此产生了一些误解。简而言之，socket就是进程之间进行通信的一种约定，或者说是在程序中对TCP和UDP协议的一种封装。</p><h2 id="一个最简单的socket示例"><a href="#一个最简单的socket示例" class="headerlink" title="一个最简单的socket示例"></a>一个最简单的socket示例</h2><p>先看完整代码：</p><ul><li>发送端sender.cpp:<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>int main(){<br>    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>    struct sockaddr_in serv_addr;<br>    memset(&amp;serv_addr, 0, sizeof(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = inet_addr(“127.0.0.1”);<br>    serv_addr.sin_port = htons(1234);<br>    bind(serv_sock, (struct sockaddr*) &amp;serv_addr, sizeof(serv_addr));<br>    listen(serv_sock, 20);</p><pre><code>struct sockaddr_in clnt_addr;socklen_t clnt_addr_size = sizeof(clnt_addr);int clnt_sock = accept(serv_sock, (struct sockaddr*) &amp;clnt_addr, &amp;clnt_addr_size);char str[] = "hello World!";send(clnt_sock, str, sizeof(str), 0);close(clnt_sock);close(serv_sock);</code></pre><p>}</p><pre><code>`int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);`    首先通过socket函数定义了一个本地的socket：serv_sock。由于在Linux系统中万物皆文件，socket也不例外，socket函数返回值就是创建好的socket的文件描述符，是一个整数。后面我们就通过这个文件描述符来操作serv _sock这个socket。    然后看socket函数的参数：AF_INET表示使用ipv4地址；SOCK _STREAM表示使用面向连接的数据传输方式；IPPROTO _TCP表示使用TCP协议。同理对于UDP协议也有相应的参数。    但是现在我们只有一个socket，并不知道他的地址，端口号，也就没法和外间进行连接。在C++中专门有一个数据结构来存储socket的各个属性值，看如下代码段：```cpp    struct sockaddr_in serv_addr;    memset(&amp;serv_addr, 0, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");    serv_addr.sin_port = htons(1234);</code></pre><p>sockaddr_ in 便是这个数据结构，其中定义了socket使用的协议，地址和端口号。<br>    单独定义这些也不够，这只是一条数据，需要和一个特定的socket绑定起来才能构成一个完整的socket。在C++中使用bind()函数进行绑定操作。<br><code>bind(serv_sock,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr));</code><br>    到这就构成了一个完整的socket。然后使用listen()函数使其进入监听状态，就可以被别的socket连接了。<code>listen(serv_sock, 20);</code>第一个参数指定了哪个socket进入监听状态；第二个参数设定了socket连接请求队列的长度。但是listen函数并不是真正的和某个socket进行了连接，它只是将socket的状态进行了转变。<br>    socket()函数创建的socket默认处于“主动连接”状态，并不会接收别的socket的连接请求。为了能够接收别的进程发来的请求，就需要单独指定一下这个socket的状态，即listen()函数的功能。<br>    然后我们要接受其他进程的连接请求，我们需要创建一个socket作为这个链接的载体。就好比是你在网络中设置了一块共享硬盘，然后将其映射到本地的过程。这个新创建的socket就是你给这个网络硬盘分配的盘号（文件名，挂载点），发起网络连接的进程就相当于网络硬盘。接下来执行真正的连接操作。</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token keyword">struct</span> sockaddr_in clnt_addr<span class="token punctuation">;</span>    socklen_t clnt_addr_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clnt_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> clnt_sock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>clnt_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clnt_addr_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先是定义一个地址结构，用于接收发起请求的socket的属性信息。然后通过accept函数接收实际的请求，返回值是接收到的“socket”的文件描述符。accept()函数第一个参数是接收连接请求的socket的文件描述符，即要将请求连接到哪个socket上。需要注意的是 <strong>程序一旦运行到accpet()函数，就会进入阻塞状态</strong> ， 直到处理了一个连接请求程序才会继续。</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello World!"</span><span class="token punctuation">;</span>    <span class="token function">send</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>建立连接之后，通过send()函数发送消息即可。第一个参数为目的socket的文件描述符；第二个参数为要发送的消息，即消息存放的地址；第三个参数为要发送的数据的大小；第四个参数为flag，用于设置一些特殊的操作，一般设置为0；返回值为实际发送的数据的大小，如果发送失败返回-1。<br>    需要注意的是，send()函数只是把要发送的数据存放到发送缓冲区，最终的发送是由协议完成的。因此如果数据过大就可能存在一次发送不完的情况，需要单独处理一下。<br>    最后，使用close()函数将socket关闭即可。</p><ul><li>接收端receiver.cpp<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>int main(){<br>    int sock = socket(AF_INET, SOCK_STREAM, 0);<br>    struct sockaddr_in serv_addr;<br>    memset(&amp;serv_addr, 0, sizeof(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = inet_addr(“127.0.0.1”);<br>    serv_addr.sin_port = htons(1234);<br>    connect(sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));</p><pre><code>char buffer[40];recv(sock, buffer, sizeof(buffer)-1, 0);printf("Message form server: %s\n", buffer);close(sock);return 0;</code></pre><p>}</p><pre><code>接收端和发送端比较类似，这里就挑不同的地方来说。    首先是接收端作为发起连接的一方，不需要设置listen()函数，socket默认就是主动连接状态。在确定了要连接的socket的ip和端口号之后，通过connect()进行连接即可。这里不需要为socket绑定一个端口号，因为用户并不会关心哪个端口和服务器建立了连接，系统会自动进行分配，只需要知道目的地址和端口就可以达到连接的目的。简单来说就是如果需要在连接建立之前，知道具体的端口号的话就需要使用bind()函数确定一下。如果一定要指定一个端口号也是可以的。    如果要读取消息，使用recv()函数即可。当然在Linux系统中，socket既然作为文件，当然也可以使用write/read函数了。当然这里由于协议的现实，如果数据过大可能不能一次性接收完全，就需要单独处理。## 几个小坑1.     最开始在做的时候，为了测试send函数的发送机制，尝试了连续两次send消息“hello world”然后使用一个recv接收，但是一直只能收到一个，误以为一个recv只能接收一个send发出的消息。但是这个结论和网上所有对于socket的讲解都不符合，也和我自己对网络协议的认知不符合，最后多次调试才发现原来是c++字符串中的结束字符的原因。recv实际上是收到了两个send发出的消息，但是在printf的时候，遇到了\0’就自动停止了，后面的消息没有被打印出来。所以在发送字符串的时候只需要发送实际的字符数据即可，不需要发送’\0’。    Server端连续发送两次“hello” receiver接收一次只能显示一个“hello”原因：Server每次发送的number为6 即包含了结束字符，实际上receiver接收到了两次“hello”，但是后一次因为第一个“hello”的结束字符而无法被解析出来。2. 接着上一个问题，我之所以会发出带有结束符的字符串消息，是因为我在确定消息长度的时候使用了sizeof()函数。但是这个函数实际上返回的是你开辟的空间的大小，不管你是否填充了实际的内容；对于字符串，想要得到实际的字符串长度，需要使用strlen()函数。具体的两个函数的效果演示如果。&lt;img src="/Users/mastercai/Desktop/blog/source/_posts/C-socket编程小结/67EA50FB-C013-4E70-91CE-428FDA01C44E.png" alt="67EA50FB-C013-4E70-91CE-428FDA01C44E" style="zoom: 67%;" /&gt;3.  对于发送/接收不完全的数据，需要特别的处理，这里给出两个比较通用的函数实现。```cppint RecvAll(int &amp;sock, unsigned char *image_recv_data, int image_len) {  int recv_image_num;  int remain_size = image_len;  int point = 0;  unsigned char image_recv_buff[image_len];  //分段接收  while (remain_size &gt; 0) {    recv_image_num = recv(sock, image_recv_buff, remain_size, 0);    for (int i = 0; i &lt; recv_image_num; ++i) {      image_recv_data[point + i] = image_recv_buff[i];    }    remain_size = remain_size - recv_image_num;    point += recv_image_num;    printf("recv %d bytes data, remain %d bytes data\n", recv_image_num,           remain_size);  }  return point;}int SendAll(int &amp;sock, unsigned char *data_sent, int data_len) {  int sent_data_num;  int remain_size = data_len;  int point = 0;  while (remain_size &gt; 0) {    sent_data_num = send(sock, data_sent, data_len, 0);    remain_size = remain_size - sent_data_num;    point += sent_data_num;    printf("recv %d bytes data, remain %d bytes data\n", sent_data_num,           remain_size);  }  return point;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-socket编程小结&quot;&gt;&lt;a href=&quot;#C-socket编程小结&quot; class=&quot;headerlink&quot; title=&quot;C++ socket编程小结&quot;&gt;&lt;/a&gt;C++ socket编程小结&lt;/h1&gt;&lt;p&gt;#随手笔记&lt;br&gt;    最近做毕设的时候涉及到了这
      
    
    </summary>
    
    
      <category term="C++" scheme="http://blog.master-cai.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="http://blog.master-cai.xyz/tags/C/"/>
    
      <category term="socket" scheme="http://blog.master-cai.xyz/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>1010 Radix</title>
    <link href="http://blog.master-cai.xyz/posts/7481.html"/>
    <id>http://blog.master-cai.xyz/posts/7481.html</id>
    <published>2020-05-23T10:05:57.000Z</published>
    <updated>2020-05-23T11:12:59.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1010-Radix"><a href="#1010-Radix" class="headerlink" title="1010 Radix"></a>1010 Radix</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is <code>yes</code>, if 6 is a decimal number and 110 is a binary number.</p><p>Now for any pair of positive integers <em>N</em>1 and <em>N</em>2, your task is to find the radix of one number while that of the other is given.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies a line which contains 4 positive integers:</p><pre><code>N1 N2 tag radix</code></pre><p>Here <code>N1</code> and <code>N2</code> each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, <code>a</code>-<code>z</code> } where 0-9 represent the decimal numbers 0-9, and <code>a</code>-<code>z</code> represent the decimal numbers 10-35. The last number <code>radix</code> is the radix of <code>N1</code> if <code>tag</code> is 1, or of <code>N2</code> if <code>tag</code> is 2.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the radix of the other number so that the equation <code>N1</code> = <code>N2</code> is true. If the equation is impossible, print <code>Impossible</code>. If the solution is not unique, output the smallest possible radix.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><pre class="line-numbers language-in"><code class="language-in">6 110 1 10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><pre class="line-numbers language-out"><code class="language-out">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><pre class="line-numbers language-in"><code class="language-in">1 ab 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><pre class="line-numbers language-out"><code class="language-out">Impossible<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题大体上的思路比较简单，就是使用二分查找的思想，找到合适的那个radix。但是细节上的东西非常多。首先一个坑的点就是题目中没有给出radix等数据的范围，必须要使用long long类型才行，其转化过程中还可能产生溢出。下面结合代码分析</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cctype></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">convert</span><span class="token punctuation">(</span>string n<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> radix<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//进制转换 radix进制转为10</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>n<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> n<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        tmp <span class="token operator">=</span> <span class="token function">isdigit</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">*</span>it<span class="token operator">-</span><span class="token string">'0'</span><span class="token operator">:</span><span class="token operator">*</span>it<span class="token operator">-</span><span class="token string">'a'</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>        sum <span class="token operator">+</span><span class="token operator">=</span> tmp <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span>radix<span class="token punctuation">,</span> index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 二分法 寻找合适的radix n是待确定的数字 num是确定进制的数字</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">find_radix</span><span class="token punctuation">(</span>string n<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">char</span> it <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// stl库 寻找最大的元素</span>    <span class="token comment" spellcheck="true">// 这里使用 max_element用作下限 是因为一个数中不会出现比进制更大的digit</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> low <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token operator">?</span>it<span class="token operator">-</span><span class="token string">'0'</span><span class="token operator">:</span>it<span class="token operator">-</span><span class="token string">'a'</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将digit转化为数值</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> high <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> low<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用两者中较大的一个作上限</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 根据mid进制转换的结果</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token operator">||</span> t<span class="token operator">></span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">==</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string n1<span class="token punctuation">,</span> n2<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> tag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> radix<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> result_radix<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n1 <span class="token operator">>></span> n2 <span class="token operator">>></span> tag <span class="token operator">>></span> radix<span class="token punctuation">;</span>    result_radix <span class="token operator">=</span> tag<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token function">find_radix</span><span class="token punctuation">(</span>n2<span class="token punctuation">,</span> <span class="token function">convert</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> radix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">find_radix</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> <span class="token function">convert</span><span class="token punctuation">(</span>n2<span class="token punctuation">,</span> radix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result_radix <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> result_radix<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1010-Radix&quot;&gt;&lt;a href=&quot;#1010-Radix&quot; class=&quot;headerlink&quot; title=&quot;1010 Radix&quot;&gt;&lt;/a&gt;1010 Radix&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="进制转换" scheme="http://blog.master-cai.xyz/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="二分" scheme="http://blog.master-cai.xyz/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>1085_Perfect_Sequence</title>
    <link href="http://blog.master-cai.xyz/posts/39771.html"/>
    <id>http://blog.master-cai.xyz/posts/39771.html</id>
    <published>2020-05-23T02:48:00.000Z</published>
    <updated>2020-05-23T11:12:59.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1085-Perfect-Sequence"><a href="#1085-Perfect-Sequence" class="headerlink" title="1085 Perfect Sequence"></a>1085 Perfect Sequence</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a sequence of positive integers and another positive integer <em>p</em>. The sequence is said to be a <strong>perfect sequence</strong> if <em>M</em>≤<em>m</em>×<em>p</em> where <em>M</em> and <em>m</em> are the maximum and minimum numbers in the sequence, respectively.</p><p>Now given a sequence and a parameter <em>p</em>, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive integers <em>N</em> and <em>p</em>, where <em>N</em> (≤105) is the number of integers in the sequence, and <em>p</em> (≤109) is the parameter. In the second line there are <em>N</em> positive integers, each is no greater than 109.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre class="line-numbers language-in"><code class="language-in">10 82 3 20 4 5 1 6 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre class="line-numbers language-out"><code class="language-out">8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题要求的是一个序列，因此就是从这N个数中选择若干个就可以了（不是子串）。看题目条件，要求选出的数中的最大值不超过最小值的p倍。为了方便处理，我们可以先将序列进行排序，这样问题就转化成了求一个子串的问题了。对于这种的问题，最常见的做法就是双指针。设置两个指针作为区间的左右端点，然后根据条件进行滑动，最终取最大值即可。但是本题还有一种做法，对于有序序列而言，求一个特定条件的数字，用二分查找无疑是最快的方法。因此，本题一共有两（三）种解法，下面直接看代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li><p>二分</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;climits></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">;</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">binsearh</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> bound<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>N<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> bound<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> N<span class="token number">-1</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>bound<span class="token punctuation">)</span><span class="token punctuation">{</span>            l <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            r <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>N<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> M<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> m<span class="token operator">=</span>INT_MAX<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//    int i=0, j=0;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">binsearch</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> x<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="2"><li><p>std::upper_bound</p><p>这里先补充一下，std库中有两个三个二分搜索的实现，其中upper_bound和lower_bound用法比较相似：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 在a.begin()到a.end()范围内，搜索第一个大于bound的元素，返回其迭代器</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bound<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在a.begin()到a.end()范围内，搜索第一个大于等于bound的元素，返回其迭代器</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bound<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>目前来看，这两个函数的唯一区别就是是否可以等于。下面看代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by masterCai on 2020/5/23.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> p<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">upper_bound</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> x<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>双指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by masterCai on 2020/5/23.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> p<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>j <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>p<span class="token operator">>=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            j<span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> j<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1085-Perfect-Sequence&quot;&gt;&lt;a href=&quot;#1085-Perfect-Sequence&quot; class=&quot;headerlink&quot; title=&quot;1085 Perfect Sequence&quot;&gt;&lt;/a&gt;1085 Perfect Sequence&lt;/
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="二分" scheme="http://blog.master-cai.xyz/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="双指针" scheme="http://blog.master-cai.xyz/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>1038 Recover the Smallest Number</title>
    <link href="http://blog.master-cai.xyz/posts/62891.html"/>
    <id>http://blog.master-cai.xyz/posts/62891.html</id>
    <published>2020-05-22T23:57:22.000Z</published>
    <updated>2020-05-23T11:12:59.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1038-Recover-the-Smallest-Number"><a href="#1038-Recover-the-Smallest-Number" class="headerlink" title="1038 Recover the Smallest Number"></a>1038 Recover the Smallest Number</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given { 32, 321, 3214, 0229, 87 }, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case gives a positive integer <em>N</em> (≤104) followed by <em>N</em> number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the smallest number in one line. Notice that the first digit must not be zero.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre class="line-numbers language-in"><code class="language-in">5 32 321 3214 0229 87<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre class="line-numbers language-out"><code class="language-out">22932132143287<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题如果能够想到正确的贪心算法就很简单，不然就不容易做对。一开始是先将所有数据用int读入自动去0，然后发现这样会去掉很多不应该去掉的0，比如<code>1 10 -&gt; 101</code>这样的情况。然后就直接按照string读入，在cmp的时候，按照每一位的大小来排序，位数不够则循环补上。但是还有测试点无法通过，最后查看题解，方法非常巧妙，直接用a+b和b+a进行比较，仔细一想好像就是我的cmp函数的简化表达版。。我以为我到了第三层，结果题解在第五层。代码也很简单，直接贴一下好了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by masterCai on 2020/5/22.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bool cmp(string &amp;a, string &amp;b){</span><span class="token comment" spellcheck="true">//    int s1=a.size(), s2=b.size();</span><span class="token comment" spellcheck="true">//    int pos = 0;</span><span class="token comment" spellcheck="true">//    for (pos = 0; pos &lt; s1 &amp;&amp; pos &lt; s2; ++pos) {</span><span class="token comment" spellcheck="true">//        if (a[pos] != b[pos]){</span><span class="token comment" spellcheck="true">//            return a[pos] &lt; b[pos];</span><span class="token comment" spellcheck="true">//        }</span><span class="token comment" spellcheck="true">//    }</span><span class="token comment" spellcheck="true">//    if(pos &lt; s1){</span><span class="token comment" spellcheck="true">//        int i = 0;</span><span class="token comment" spellcheck="true">//        while (i&lt;s2 &amp;&amp; pos &lt; s1){</span><span class="token comment" spellcheck="true">//            if(a[pos] != b[i]){</span><span class="token comment" spellcheck="true">//                return a[pos] &lt; b[i];</span><span class="token comment" spellcheck="true">//            }</span><span class="token comment" spellcheck="true">//            i += 1;</span><span class="token comment" spellcheck="true">//            pos += 1;</span><span class="token comment" spellcheck="true">//        }</span><span class="token comment" spellcheck="true">//    } else{</span><span class="token comment" spellcheck="true">//        int i = 0;</span><span class="token comment" spellcheck="true">//        while (i&lt;s1 &amp;&amp; pos &lt; s2){</span><span class="token comment" spellcheck="true">//            if(a[i] != b[pos]){</span><span class="token comment" spellcheck="true">//                return a[i] &lt; b[pos];</span><span class="token comment" spellcheck="true">//            }</span><span class="token comment" spellcheck="true">//            i += 1;</span><span class="token comment" spellcheck="true">//            pos += 1;</span><span class="token comment" spellcheck="true">//        }</span><span class="token comment" spellcheck="true">//    }</span><span class="token comment" spellcheck="true">//    return a&lt;b;</span><span class="token comment" spellcheck="true">//}</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token operator">&lt;</span>b<span class="token operator">+</span>a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    string ans<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ans<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ans<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1038-Recover-the-Smallest-Number&quot;&gt;&lt;a href=&quot;#1038-Recover-the-Smallest-Number&quot; class=&quot;headerlink&quot; title=&quot;1038 Recover the Smallest Nu
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="贪心" scheme="http://blog.master-cai.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>1067 Sort with Swap(0,i)</title>
    <link href="http://blog.master-cai.xyz/posts/34414.html"/>
    <id>http://blog.master-cai.xyz/posts/34414.html</id>
    <published>2020-05-22T07:05:10.000Z</published>
    <updated>2020-05-22T23:56:57.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1067-Sort-with-Swap-0-i"><a href="#1067-Sort-with-Swap-0-i" class="headerlink" title="1067 Sort with Swap(0, i)"></a>1067 Sort with Swap(0, i)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given any permutation of the numbers {0, 1, 2,…, <em>N</em>−1}, it is easy to sort them in increasing order. But what if <code>Swap(0, *)</code> is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:</p><pre><code>Swap(0, 1) =&gt; {4, 1, 2, 0, 3}Swap(0, 3) =&gt; {4, 1, 2, 3, 0}Swap(0, 4) =&gt; {0, 1, 2, 3, 4}</code></pre><p>Now you are asked to find the minimum number of swaps need to sort the given permutation of the first <em>N</em> nonnegative integers.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case, which gives a positive <em>N</em> (≤105) followed by a permutation sequence of {0, 1, …, <em>N</em>−1}. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, simply print in a line the minimum number of swaps need to sort the given permutation.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre class="line-numbers language-in"><code class="language-in">103 5 7 2 6 4 9 0 8 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre class="line-numbers language-out"><code class="language-out">9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题的主要思路就是贪心算法，即每次交换的时候，都尽可能的使一个元素正确的归位。最直接的想法就是，用一个数组记录原始数据，然后用一个hash map记录元素所在位置。每次都从0元素开始，当0元素不在正确的位置时，将其和0所在的位置应该放置的元素进行交换，这样就完成了一个元素的归位。当出现0元素已经归位但是整体序列还不是有序的情况时，我们选择序列中的一个还处于无序状态的元素，将其和0元素交换位置，然后再重复上述过程。最初的想法就是，没交换一次，就对整体的序列进行一次扫描判断是否全部有序，但是有两个样例无法通过。后来对这个判断是否有序的方法进行了改进，在最开始录入原始数据的时候，记录一下一共有多少个元素是无序的，然后循环的退出条件就变成了判断当前归位的元素数是否达到要求即可。这样优化了以后还是无法通过样例。。最后参考了一下题解，发现问题出在了寻找一个处于无序状态的元素这一步。题解给出的方法是再维护一个变量，记录当前未复位的位置最小的一个元素的位置。这样整体程序就显得比较复杂了。然后我又发现了一种更加巧妙的解法，整体思路是：使用a[t]=i记录t在i位置，依次遍历每个位置，如果当前位置不正确，则让0号来执行下列操作使其回到正确位置：如果0号现在不在有序位置（0位），那就让0号和此数字交换位置，直到0号回到有序位置。然后再次检查此位置是否是正确的，如果不是，就让0号和其交换位置，如果是，那就直接跳过。这里这一步就是此算法中最巧妙的一步，用这种方式完成了“维护一个未归位的元素的最小位置”这一操作。到达最后一个位置的时候，如果0号和最后一个数字都有序就正确，否则交换位置即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> t<span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">10010</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cin <span class="token operator">>></span> t<span class="token punctuation">;</span>        a<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 当0归位但是a[i]还无序时 交换</span>                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> cnt<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1067-Sort-with-Swap-0-i&quot;&gt;&lt;a href=&quot;#1067-Sort-with-Swap-0-i&quot; class=&quot;headerlink&quot; title=&quot;1067 Sort with Swap(0, i)&quot;&gt;&lt;/a&gt;1067 Sort with 
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="贪心" scheme="http://blog.master-cai.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>1012 The Best Rank</title>
    <link href="http://blog.master-cai.xyz/posts/18502.html"/>
    <id>http://blog.master-cai.xyz/posts/18502.html</id>
    <published>2020-05-20T02:43:48.000Z</published>
    <updated>2020-05-20T03:05:09.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1012-The-Best-Rank"><a href="#1012-The-Best-Rank" class="headerlink" title="1012 The Best Rank"></a>1012 The Best Rank</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: <code>C</code> - C Programming Language, <code>M</code> - Mathematics (Calculus or Linear Algrbra), and <code>E</code> - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p><p>For example, The grades of <code>C</code>, <code>M</code>, <code>E</code> and <code>A</code> - Average of 4 students are given as the following:</p><pre><code>StudentID  C  M  E  A310101     98 85 88 90310102     70 95 88 84310103     82 87 94 88310104     91 91 91 91</code></pre><p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 2 numbers <em>N</em> and <em>M</em> (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then <em>N</em> lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of <code>C</code>, <code>M</code> and <code>E</code>. Then there are <em>M</em> lines, each containing a student ID.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each of the <em>M</em> students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p><p>The priorities of the ranking methods are ordered as <code>A</code> &gt; <code>C</code> &gt; <code>M</code> &gt; <code>E</code>. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p><p>If a student is not on the grading list, simply output <code>N/A</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre class="line-numbers language-in"><code class="language-in">5 6310101 98 85 88310102 70 95 88310103 82 87 94310104 91 91 91310105 85 90 90310101310102310103310104310105999999<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre class="line-numbers language-out"><code class="language-out">1 C1 M1 E1 A3 AN/A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题的基本思路其实不太难，就是对数据按照要求进行排序即可。但是细节部分问题比较多，不注意的话无法拿到所有分数。首先，对于A，题目中没有说明是否需要四舍五入，因此有一个很巧妙的处理方法，就是只存储总分不计算平均值（题目中只要求排名），这样得出的排名必然是对的。如果一定要计算平均分，可以使用库函数或者加0.5再直接取整。第二就是这个排名，如果有并列的情况，排名不能顺延而是直接按照人数排名，即：<code>1 1 3 4 5</code>。最后就是这个变量的存储问题，本题设计的变量较多，4个分数，4个排名，可以直接存储在数组中，如果单独明明代码重复太大（前两天我还说别人来着。。。）本题就是麻烦点，注意细节。（但我确实没调出来。。）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> node <span class="token punctuation">{</span>    <span class="token keyword">int</span> id<span class="token punctuation">,</span> best<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// best存储最优排名的下标</span>    <span class="token keyword">int</span> score<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rank<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// A C M E</span><span class="token punctuation">}</span>stu<span class="token punctuation">[</span><span class="token number">2005</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> exist<span class="token punctuation">[</span><span class="token number">1000000</span><span class="token punctuation">]</span><span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// exist 用来判断是否存在</span><span class="token keyword">bool</span> <span class="token function">cmp1</span><span class="token punctuation">(</span>node a<span class="token punctuation">,</span> node b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">.</span>score<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">.</span>score<span class="token punctuation">[</span>flag<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> id<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3.0</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> flag <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> flag<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// flag用来确定当前排序的是哪个分数</span>        <span class="token function">sort</span><span class="token punctuation">(</span>stu<span class="token punctuation">,</span> stu <span class="token operator">+</span> n<span class="token punctuation">,</span> cmp1<span class="token punctuation">)</span><span class="token punctuation">;</span>        stu<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rank<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rank<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">==</span> stu<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">[</span>flag<span class="token punctuation">]</span><span class="token punctuation">)</span>                stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rank<span class="token punctuation">[</span>flag<span class="token punctuation">]</span> <span class="token operator">=</span> stu<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rank<span class="token punctuation">[</span>flag<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        exist<span class="token punctuation">[</span>stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>best <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minn <span class="token operator">=</span> stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里是求排名的最小值</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rank<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minn<span class="token punctuation">)</span> <span class="token punctuation">{</span>                minn <span class="token operator">=</span> stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rank<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                stu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>best <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> exist<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> best <span class="token operator">=</span> stu<span class="token punctuation">[</span>temp<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>best<span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %c\n"</span><span class="token punctuation">,</span> stu<span class="token punctuation">[</span>temp<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rank<span class="token punctuation">[</span>best<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>best<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"N/A\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1012-The-Best-Rank&quot;&gt;&lt;a href=&quot;#1012-The-Best-Rank&quot; class=&quot;headerlink&quot; title=&quot;1012 The Best Rank&quot;&gt;&lt;/a&gt;1012 The Best Rank&lt;/h1&gt;&lt;h2 id=&quot;题
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="sort" scheme="http://blog.master-cai.xyz/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>1046 Shortest Distance</title>
    <link href="http://blog.master-cai.xyz/posts/64131.html"/>
    <id>http://blog.master-cai.xyz/posts/64131.html</id>
    <published>2020-05-16T23:58:55.000Z</published>
    <updated>2020-05-17T00:16:59.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1046-Shortest-Distance"><a href="#1046-Shortest-Distance" class="headerlink" title="1046 Shortest Distance"></a><strong>1046</strong> <strong>Shortest Distance</strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The task is really simple: given <em>N</em> exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer <em>N</em> (in [3,105]), followed by <em>N</em> integer distances <em>D</em>1 <em>D</em>2 ⋯ <em>D**N</em>, where <em>D**i</em> is the distance between the <em>i</em>-th and the (<em>i</em>+1)-st exits, and <em>D**N</em> is between the <em>N</em>-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer <em>M</em> (≤104), with <em>M</em> lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to <em>N</em>. It is guaranteed that the total round trip distance is no more than 107.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print your results in <em>M</em> lines, each contains the shortest distance between the corresponding given pair of exits.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre class="line-numbers language-in"><code class="language-in">5 1 2 4 14 931 32 54 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre class="line-numbers language-out"><code class="language-out">3107<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目本身没有什么难度，最暴力的做法就是对于每一个起点，同时从两个方向进行搜索，然后对结果进行比较。但是这样的话时间复杂度比较高，最后一个测试样例无法通过。题解中的方法比较巧妙，可以说是利用了动态规划的思想来解决的。将dis数组定义为从点1到点i的下一个节点的距离，这里定义为点i的下一个节点而不是到点i的距离，原因是如果那样表示的话，就无法表示从点N到点1了（中间没有点0），因此这样定义方便一些。另一种结局思路就是加上一个“点0“，点0到点1距离为0也可。如果要求点i到点j的距离，那么就是<code>dis[j-1]-dis[i-1]</code>。那么另一个方向的走法要怎么计算呢？因为题中给出的是一个环，即距离总长度是不变的，所以我们只需要用总长度减去这个距离，就是从另一个方向走需要的距离了（这两个点将圆分成了两半）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by masterCai on 2020/5/15.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dis</span><span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">+</span><span class="token operator">=</span> tmp<span class="token punctuation">;</span>        dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> M<span class="token punctuation">;</span>    cin <span class="token operator">>></span> M<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>left<span class="token punctuation">,</span> <span class="token operator">&amp;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> dis<span class="token punctuation">[</span>right<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span> dis<span class="token punctuation">[</span>left<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> sum<span class="token operator">-</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1046-Shortest-Distance&quot;&gt;&lt;a href=&quot;#1046-Shortest-Distance&quot; class=&quot;headerlink&quot; title=&quot;1046 Shortest Distance&quot;&gt;&lt;/a&gt;&lt;strong&gt;1046&lt;/strong
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="算法" scheme="http://blog.master-cai.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1143 Lowest Common Ancestor</title>
    <link href="http://blog.master-cai.xyz/posts/63296.html"/>
    <id>http://blog.master-cai.xyz/posts/63296.html</id>
    <published>2020-05-15T03:20:14.000Z</published>
    <updated>2020-05-17T00:16:59.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1143-Lowest-Common-Ancestor"><a href="#1143-Lowest-Common-Ancestor" class="headerlink" title="1143 Lowest Common Ancestor"></a><strong>1143</strong> <strong>Lowest Common Ancestor</strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.A binary search tree (BST) is recursively defined as a binary tree which has the following properties:The left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than or equal to the node's key.Both the left and right subtrees must also be binary search trees.Given any two nodes in a BST, you are supposed to find their LCA.Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int.Output Specification:For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the BST, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found..Sample Input:6 86 3 1 2 5 4 8 72 58 71 912 -30 899 99Sample Output:LCA of 2 and 5 is 3.8 is an ancestor of 7.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found.</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题是将BST和LCA算法结合起来进行考察，看起来很复杂，实际上是降低了难度。最直接的想法就是先利用pre数组构建出一个BST，然后在用LCA算法搜索结果，但是题目限制了时间为200ms，这样的话部分样例无法通过。题解的思路就非常巧妙，直接对pre数组进行遍历，每次比较带查询数据x，y和当前元素的大小关系即可确定位置。原理是利用了BST的属性，大小关系即确定了元素之间的位置关系。大的元素一点在右，小的元素一定在左，因此只要满足对于一个元素a，<code>x&gt;=a&amp;&amp;y&lt;=a</code>或者<code>y&gt;=a&amp;&amp;x&lt;=a</code>即可说明x，y在a的两侧，即公共节点。其他边界条件再加以判断即可。另题解中有另外一个技巧：利用一个map来存储元素是否存在，提高了速度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by masterCai on 2020/5/14.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> M<span class="token punctuation">,</span> N<span class="token punctuation">;</span>    cin <span class="token operator">>></span> M <span class="token operator">>></span> N<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pre</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token punctuation">[</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            a <span class="token operator">=</span> pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">>=</span>x <span class="token operator">&amp;&amp;</span> a <span class="token operator">&lt;=</span> y<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>a<span class="token operator">>=</span>y <span class="token operator">&amp;&amp;</span> a<span class="token operator">&lt;=</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>m<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>m<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: %d and %d are not found.\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>m<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token operator">!</span>m<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: %d is not found.\n"</span><span class="token punctuation">,</span> <span class="token operator">!</span>m<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span>x <span class="token operator">||</span> a<span class="token operator">==</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d is an ancestor of %d.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> a <span class="token operator">==</span> x <span class="token operator">?</span> y <span class="token operator">:</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"LCA of %d and %d is %d.\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1143-Lowest-Common-Ancestor&quot;&gt;&lt;a href=&quot;#1143-Lowest-Common-Ancestor&quot; class=&quot;headerlink&quot; title=&quot;1143 Lowest Common Ancestor&quot;&gt;&lt;/a&gt;&lt;stro
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="二叉搜索树" scheme="http://blog.master-cai.xyz/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="LCA" scheme="http://blog.master-cai.xyz/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>1141 PAT Ranking of Institutions</title>
    <link href="http://blog.master-cai.xyz/posts/52699.html"/>
    <id>http://blog.master-cai.xyz/posts/52699.html</id>
    <published>2020-05-13T23:54:05.000Z</published>
    <updated>2020-05-17T00:16:59.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1141-PAT-Ranking-of-Institutions"><a href="#1141-PAT-Ranking-of-Institutions" class="headerlink" title="1141 PAT Ranking of Institutions"></a><strong>1141</strong> <strong>PAT Ranking of Institutions</strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>After each PAT, the PAT Center will announce the ranking of institutions based on their students' performances. Now you are asked to generate the ranklist.Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10^ID Score School where ID is a string of 6 characters with the first one representing the test level: B stands for the basic level, A the advanced level and T the top level; Score is an integer in [0, 100]; and School is the institution code which is a string of no more than 6 English letters (case insensitive). Note: it is guaranteed that ID is unique for each testee.Output Specification:For each case, first print in a line the total number of institutions. Then output the ranklist of institutions in nondecreasing order of their ranks in the following format:Rank School TWS Nswhere Rank is the rank (start from 1) of the institution; School is the institution code (all in lower case); ; TWS is the total weighted score which is defined to be the integer part of ScoreB/1.5 + ScoreA + ScoreT*1.5, where ScoreX is the total score of the testees belong to this institution on level X; and Ns is the total number of testees who belong to this institution.The institutions are ranked according to their TWS. If there is a tie, the institutions are supposed to have the same rank, and they shall be printed in ascending order of Ns. If there is still a tie, they shall be printed in alphabetical order of their codes.Sample Input:10A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypuSample Output:51 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题其实没有什么难度，只是在做的时候，将问题想复杂了，导致卡壳。还是有两个点需要注意一下：</p><ol><li>scanf不能对string类型进行赋值，如果一点需要，需要先分配string空间（s.resize(100))</li><li>对于问题中的多个统计要求，其实大可不必集成在一个数据结构中，因为这是算法题而不是工程，不需要考虑其他方面，做出答案即可，可以用空间换时间即可。</li><li>cctype 这个头文件很好用 直接转换大小写</li><li>本题中要求只保留整数部分，但是需要全部累计后再截取，而不是每个结果都截取一次</li><li>c++中map的遍历，类型是pair</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++"><code class="language-c++">//// Created by masterCai on 2020/5/13.//#include <iostream>#include <vector>#include <algorithm>#include <cctype>#include <unordered_map>using namespace std;struct ins{    string school;    int TWS, Ns;};bool cmp(ins a, ins b){    if(a.TWS != b.TWS){        return a.TWS > b.TWS;    } else if(a.Ns != b.Ns){        return a.Ns < b.Ns;    } else{        return a.school < b.school;    }}int main(){    int n;    cin >> n;    unordered_map<string, int> cnt; //school-> Ns    unordered_map<string, double> sum; // school-> TWS    for (int i = 0; i < n; ++i) {        ins* in = new ins();        string ID;        double score;        string school;//        scanf("%s %lf %s", &ID, &score, &school);        cin >> ID >> score >> school;        for (int j = 0; j < school.length(); ++j) {            school[j] = tolower(school[j]);        }        switch (ID[0]) {            case 'B': score = score/1.5;                break;            case 'T': score = score*1.5;                break;        }        sum[school] += score;        cnt[school] += 1;    }    vector<ins> ans;    for(auto it = cnt.begin(); it != cnt.end(); it++){        ans.push_back(ins{it->first, (int)sum[it->first], cnt[it->first]});    }    sort(ans.begin(), ans.end(), cmp);    int rank = 0, pres=-1;    printf("%d\n", (int)ans.size());    for (int i = 0; i < ans.size(); ++i) {        if(pres != ans[i].TWS){ //判断排名是否一致            rank = i+1;        }        pres = ans[i].TWS;        printf("%d ", rank);        cout << ans[i].school;        printf(" %d %d\n", ans[i].TWS, ans[i].Ns);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1141-PAT-Ranking-of-Institutions&quot;&gt;&lt;a href=&quot;#1141-PAT-Ranking-of-Institutions&quot; class=&quot;headerlink&quot; title=&quot;1141 PAT Ranking of Institut
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
  </entry>
  
  <entry>
    <title>1146 Topological Order</title>
    <link href="http://blog.master-cai.xyz/posts/63733.html"/>
    <id>http://blog.master-cai.xyz/posts/63733.html</id>
    <published>2020-05-12T23:46:48.000Z</published>
    <updated>2020-05-17T00:16:59.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1146-Topological-Order"><a href="#1146-Topological-Order" class="headerlink" title="1146 Topological Order"></a><strong>1146</strong> <strong>Topological Order</strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options.Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 1,000), the number of vertices in the graph, and M (≤ 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K (≤ 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space.Output Specification:Print in a line all the indices of queries which correspond to "NOT a topological order". The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer.Sample Input:6 81 21 35 25 42 32 63 46 451 5 2 3 6 45 1 2 6 3 45 1 2 3 6 45 2 1 6 3 41 2 3 4 5 6    Sample Output:3 4</code></pre><p><img src="https://images.ptausercontent.com/5d35ed2a-4d19-4f13-bf3f-35ed59cebf05.jpg" alt="gre.jpg"></p><h3 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h3><p>topological order：拓扑排序</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题和上一题一样，都是单纯的考察数据结构知识，这次是有向无环图的拓扑排序问题。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序，从概念上来说就是由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。（不是太好理解。。就不解释了），如何判断一个图是否拓扑有序并得到一个图的拓扑排序呢？只要遵循以下步骤即可：</p><ol><li>在图中选择一个入度为0的节点；</li><li>删除该节点以及所以从该节点出发的边。（删除的顺序即为该图的一个拓扑排序）</li><li>重复上述操作，直到全部顶点被删除，或者不存在入度为0的节点。此时如果还有节点存在，说明该图非拓扑有序（存在环）。</li></ol><p>根据题意，我们不需要构建一个图的拓扑排序，我们只需要判断给出的排序是否是拓扑有序即可。那么判断的方法也很简单，对于序列的每个点，我们都判断它的入度是否为0，如果为0，删除其节点和相应的边；如果最后还有节点存在，则说明这不是一个拓扑排序。当然这里也存在技巧，即我们可以单独记录一个indegree数组来记录每个点的入度，将删除边的操作转化为将对应定点入度减一即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> N<span class="token punctuation">,</span> M<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N <span class="token operator">>></span> M<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里需要注意一下 这里声明的是一个二维数组</span>    <span class="token comment" spellcheck="true">// 另一种比较直观的二维数组声明方法是vector&lt;vector&lt;int> > g(n, vector&lt;int>(n, 0)) 声明一个nXn的全0数组</span>    <span class="token comment" spellcheck="true">//但是这种方式速度较慢 代码中这种方式声明速度上会快一些。（因为这个原因代码超时</span>    <span class="token comment" spellcheck="true">//同时作为邻接表，由于只需要用到以这个点为起点有哪些边 所以不需要完整建出二维矩阵</span>    <span class="token comment" spellcheck="true">//只需要按需讲需要的点push_back</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> g<span class="token punctuation">[</span><span class="token number">1001</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> in<span class="token punctuation">[</span><span class="token number">1001</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 存每个点的入度</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        in<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    cin <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 用于判断是否加空格</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> judge <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于判断是否为拓扑排序</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">tmp_in</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> in<span class="token operator">+</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 复制一个in数组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> a<span class="token punctuation">;</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>tmp_in<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//判断入度</span>                judge<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">:</span> g<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                tmp_in<span class="token punctuation">[</span>it<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将以a为起点的边全部删除（相应点入度减一）</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>judge<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 是拓扑排序 跳过即可</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s%d"</span><span class="token operator">:</span> flag<span class="token operator">==</span><span class="token number">1</span><span class="token operator">?</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1146-Topological-Order&quot;&gt;&lt;a href=&quot;#1146-Topological-Order&quot; class=&quot;headerlink&quot; title=&quot;1146 Topological Order&quot;&gt;&lt;/a&gt;&lt;strong&gt;1146&lt;/strong
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="拓扑排序" scheme="http://blog.master-cai.xyz/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>1145 Hashing - Average Search Time</title>
    <link href="http://blog.master-cai.xyz/posts/43043.html"/>
    <id>http://blog.master-cai.xyz/posts/43043.html</id>
    <published>2020-05-12T07:20:04.000Z</published>
    <updated>2020-05-12T09:16:19.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1145-Hashing-Average-Search-Time"><a href="#1145-Hashing-Average-Search-Time" class="headerlink" title="1145 Hashing - Average Search Time"></a>1145 Hashing - Average Search Time</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table first. Then try to find another sequence of integer keys from the table and output the average search time (the number of comparisons made to find whether or not the key is in the table). The hash function is defined to be H(key)=key%TSize where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.Input Specification:Each input file contains one test case. For each case, the first line contains 3 positive numbers: MSize, N, and M, which are the user-defined table size, the number of input numbers, and the number of keys to be found, respectively. All the three numbers are no more than 10^4. Then N distinct positive integers are given in the next line, followed by M positive integer keys in the next line. All the numbers in a line are separated by a space and are no more than 10^5.Output Specification:For each test case, in case it is impossible to insert some number, print in a line X cannot be inserted. where X is the input number. Finally print in a line the average search time for all the M keys, accurate up to 1 decimal place.Sample Input:4 5 410 6 4 15 1111 4 15 2Sample Output:15 cannot be inserted.2.8</code></pre><h3 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h3><ol><li>distinct：不同的</li><li>Quadratic probing: 平方探测</li><li>collisions: 冲突</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题没有什么特别复杂的算法思想，可以说就是单纯的考察hash表和常见的hash函数（忘了）然后就是对于输出格式的要求，下面借机会复习一下hash函数。</p><p>平方探测是开放定址法的一种递增函数，下面介绍一下常见的几种冲突解决方法。</p><h3 id="常见的冲突处理方法"><a href="#常见的冲突处理方法" class="headerlink" title="常见的冲突处理方法"></a>常见的冲突处理方法</h3><ol><li><p>开放定址法：</p><p>$$H_i=(H(key)+d_i) MOD m, i=1,2,…k(k≤m-1)$$.$H(key)$是哈希函数；m是表长，$d_i$是增长序列，常见的有如下三种：</p><ol><li>$d_i=1, 2, 3…, m-1$, 即线性探测再散列</li><li>$d_i=0, 1^2, -1^2, 2^2, -2^2,…, k^2, (k≤m/2)$, 平方探测再散列</li><li>$d_i=伪随机数$，即伪随机探测再散列</li></ol><p>这个方法的思想就是当当前地址不可行的话，就根据所选择的增长序列，更改地址直到不发生冲突或者无法插入。</p></li><li><p>再hash法</p><p>$H_i=RH_i(key)$，其中$RH_i$是不同的散列函数。这种方法就是当发生冲突时，换用不同的hash函数产生不同的地址，直到不发生冲突为止。这种方法不容易产生聚集，但是增加了计算时间。</p></li><li><p>链地址法</p><p>将关键字存储在同一地址下，产生冲突的数据就用链表的形式进行链接即可（如图）。</p><img src="/Users/mastercai/Desktop/blog/source/_posts/1145-Hashing-Average-Search-Time/image-20200512165523718.png" alt="image-20200512165523718" style="zoom:50%;"></li><li><p>建立公共溢出区域</p><p>这也是一种处理冲突的思路，设hash函数的值域是[0, m-1], 则设向量hashTable[0..m-1]为基本表，每个分量存放一个记录，另设立向量OverTable[0..v]为溢出表。所有关键字和基本表中的关键字为同义词的记录，不管他们的hash地址是多少，发生冲突就填入溢出表。</p></li></ol><p>上述四种常见的冲突解决方法，对于本题就是开放地址法的一种特殊形式。</p><h3 id="C-限定输出精度"><a href="#C-限定输出精度" class="headerlink" title="C++限定输出精度"></a>C++限定输出精度</h3><p>对于浮点数，限制输出精度应该是很常见的操作，但是由于不经常使用，这里复习一下。</p><ol><li><p>std：：setprecision()</p><p>当使用cout 时，可以使用这个函数来设定输出精度（会自动在末尾补0）,用例如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">setprecision</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> f <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//精度为5位</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>printf()</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%6.2f"</span><span class="token punctuation">,</span> floatNum<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//100.1打印出来为100.10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6表示数字至少占6字符宽度（包括小数点），2表示小数点后有两位，小数部分不够时会在后面补0。</p></li></ol><p>下面给出本题代码：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by masterCai on 2020/5/12.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">is_prime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 判断素数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">*</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 这里技巧 使用i*i判断 降低时间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> tsize<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> a<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tsize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_prime</span><span class="token punctuation">(</span>tsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//找到合适的hashTable大小</span>        tsize <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span>tsize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//hash table</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 对于每个数 先进行hash</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否可以插入</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> tsize<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 使用平方探测解决冲突</span>            <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>j<span class="token operator">*</span>j<span class="token punctuation">)</span><span class="token operator">%</span>tsize<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                v<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d cannot be inserted.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 对每个key进行查找</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> tsize<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 查找同样需要使用平方探测</span>            ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每尝试一次计数</span>            <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>j<span class="token operator">*</span>j<span class="token punctuation">)</span><span class="token operator">%</span>tsize<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//平方探测</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> a <span class="token operator">||</span> v<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果找到或者找不到则退出</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.1lf\n"</span><span class="token punctuation">,</span> ans<span class="token operator">*</span><span class="token number">1.0</span><span class="token operator">/</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//控制输出精度</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1145-Hashing-Average-Search-Time&quot;&gt;&lt;a href=&quot;#1145-Hashing-Average-Search-Time&quot; class=&quot;headerlink&quot; title=&quot;1145 Hashing - Average Searc
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="哈希" scheme="http://blog.master-cai.xyz/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="平方探测" scheme="http://blog.master-cai.xyz/tags/%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B/"/>
    
      <category term="数据结构" scheme="http://blog.master-cai.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>1151. LCA in a Binary Tree</title>
    <link href="http://blog.master-cai.xyz/posts/27259.html"/>
    <id>http://blog.master-cai.xyz/posts/27259.html</id>
    <published>2020-05-11T09:27:48.000Z</published>
    <updated>2020-05-12T09:16:19.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1151-LCA-in-a-Binary-Tree"><a href="#1151-LCA-in-a-Binary-Tree" class="headerlink" title="1151. LCA in a Binary Tree"></a>1151. LCA in a Binary Tree</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.Given any two nodes in a binary tree, you are supposed to find their LCA.Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int.Output Specification:For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the binary tree, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found..Sample Input:6 87 2 3 4 6 5 1 85 3 7 2 6 4 8 12 68 17 912 -30 899 99Sample Output:LCA of 2 and 6 is 3.8 is an ancestor of 1.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found.</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题目就是将前中序遍历构建二叉树与lca算法结合起来进行考察。这两个问题拆开来看其实都不算困难，但是结合起来以后有一定技巧。最直接的思路就是首先将二叉树构建起来，然后再dfs进行搜索即可。但是其实不需要这样麻烦，只需要在“构建”的同时进行判断即可。因此可以抽象出一个框架，对于前中序遍历确定二叉树的问题，只要保持其构建的框架不变，然后在其中添加必要的操作即可，不一定要把树构建出来。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Created by masterCai on 2020/5/7.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 因c++中不能直接找到元素对应下标，因此用map映射一下方便后续查找元素对应位置</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> pos<span class="token punctuation">;</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> pre<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//存储中序，前序序列</span><span class="token keyword">void</span> <span class="token function">lca</span><span class="token punctuation">(</span><span class="token keyword">int</span> inl<span class="token punctuation">,</span> <span class="token keyword">int</span> inr<span class="token punctuation">,</span> <span class="token keyword">int</span> preRoot<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//inl：中序left inr中序right preroot：当前的root a，b：待查询的数据</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>inl <span class="token operator">></span> inr<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 中序全部遍历完 退出</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//从pos中找到当前的root的位置 查找a，b在中序中的位置</span>    <span class="token keyword">int</span> inRoot <span class="token operator">=</span> pos<span class="token punctuation">[</span>pre<span class="token punctuation">[</span>preRoot<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> aIn <span class="token operator">=</span> pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> bIn <span class="token operator">=</span> pos<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>aIn <span class="token operator">&lt;</span> inRoot <span class="token operator">&amp;&amp;</span> bIn <span class="token operator">&lt;</span> inRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// a，b都在左边 搜索左子树即可</span>        <span class="token function">lca</span><span class="token punctuation">(</span>inl<span class="token punctuation">,</span> inRoot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> preRoot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>aIn <span class="token operator">&lt;</span> inRoot <span class="token operator">&amp;&amp;</span> bIn<span class="token operator">></span>inRoot<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>aIn <span class="token operator">></span> inRoot <span class="token operator">&amp;&amp;</span> bIn <span class="token operator">&lt;</span> inRoot<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 若a，b在两边 则找到答案了</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"LCA of %d and %d is %d.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> in<span class="token punctuation">[</span>inRoot<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>aIn <span class="token operator">></span> inRoot <span class="token operator">&amp;&amp;</span> bIn<span class="token operator">></span>inRoot<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 都在右边 搜索右子树</span>        <span class="token function">lca</span><span class="token punctuation">(</span>inRoot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> inr<span class="token punctuation">,</span> preRoot<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span><span class="token punctuation">(</span>inRoot<span class="token operator">-</span>inl<span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>aIn <span class="token operator">==</span> inRoot<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// a或b是根，则找到答案</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d is an ancestor of %d.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>bIn <span class="token operator">==</span> inRoot<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d is an ancestor of %d.\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>    cin <span class="token operator">>></span> m <span class="token operator">>></span> n<span class="token punctuation">;</span>    in<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pre<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里小技巧：在全局声明没有大小的vector，然后在得到大小后resize</span>    <span class="token comment" spellcheck="true">//（直接全局声明vector&lt;int> a(n)）这个意思。</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>in<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pos<span class="token punctuation">[</span>in<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pos<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果都没找到</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: %d and %d are not found.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> pos<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//没找到其中一个</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: %d is not found.\n"</span><span class="token punctuation">,</span> pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">lca</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//搜索即可</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1151-LCA-in-a-Binary-Tree&quot;&gt;&lt;a href=&quot;#1151-LCA-in-a-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;1151. LCA in a Binary Tree&quot;&gt;&lt;/a&gt;1151. LCA 
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="algorithm" scheme="http://blog.master-cai.xyz/tags/algorithm/"/>
    
      <category term="二叉树" scheme="http://blog.master-cai.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="中序遍历" scheme="http://blog.master-cai.xyz/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
      <category term="前序遍历" scheme="http://blog.master-cai.xyz/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>1148:Werewolf-Simple Version</title>
    <link href="http://blog.master-cai.xyz/posts/63151.html"/>
    <id>http://blog.master-cai.xyz/posts/63151.html</id>
    <published>2020-05-06T00:01:41.000Z</published>
    <updated>2020-05-06T01:31:14.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1148-Werewolf-Simple-Version"><a href="#1148-Werewolf-Simple-Version" class="headerlink" title="1148:Werewolf-Simple Version"></a>1148:Werewolf-Simple Version</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>Werewolf（狼人杀） is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game,player #1 said: "Player #2 is a werewolf.";player #2 said: "Player #3 is a human.";player #3 said: "Player #4 is a werewolf.";player #4 said: "Player #5 is a human."; andplayer #5 said: "Player #4 is a human.".Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves?Now you are asked to solve a harder version of this problem: given that there were N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves.Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (5≤N≤100). Then N lines follow and the i-th line gives the statement of the i-th player (1≤i≤N), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf.Output Specification:If a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence -- that is, for two sequences A=a[1],...,a[M] and B=b[1],...,b[M], if there exists 0≤k&lt;M such that a[i]=b[i] (i≤k) and a[k+1]&lt;b[k+1], then A is said to be smaller than B. In case there is no solution, simply print No Solution.Sample Input 1:5-2+3-4+5+4Sample Output 1:1 4    Sample Input 2:6+6+3+1-5-2+4Sample Output 2 (the solution is not unique):1 5Sample Input 3:5-2-3-4-5-1Sample Output 3:No Solution</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题的难点不在于解法，读完题目后在加上题中给出的N&lt; 100，基本上可以确定是一道直接模拟所有情况来求解的问题。对于确定的两种状态，可以用全排列的方式进行模拟，在C++中直接调用next_permutation即可。但是对于每种情况，我们都需要进行check，这也是本题稍微绕了一点的地方。</p><p>题目叙述稍微有点啰嗦，或者说是设置了障碍，一开始的想法是直接根据题意，用最直接的方法来check，结果总是会出bug，并且部分超时；后来参考了一下题解，发现题解的解法非常巧妙，充分的利用了题目给出的数据的正负关系，在设置全排列的元素时使用的就是‘1’和‘-1’（而不是0），然后利用当前位的标记状态以及其实际状态进行乘积来判断（详情见代码注释）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>参考代码版本</li></ol><pre class="line-numbers language-c++"><code class="language-c++">//// Created by masterCai on 2020/5/5.//#include <iostream>#include <vector>#include <algorithm>#include <cstring>using namespace std;int main(){    int n;    cin >> n;    vector<int> v(n+1); // v中存储所有人的陈述    for (int i = 1; i <= n; ++i) {//        scanf("%d", &v[i]);        cin >> v[i];    }    for(int i=1; i<=n; i++){        for(int j=i+1; j<=n; j++){ // i j 枚举 i和j为狼的情况            vector<int> lie, a(n+1, 1); // 将撒谎情况记录到lie中 a作为枚举的载体 初始化为全人            a[i] = a[j] = -1; // 开始枚举 -1为狼 1为人            for(int k = 1; k <= n; k++){                // 这里判断撒谎情况很巧妙                // 之前设定的-1为狼 如果玩家说i号为狼，则陈述为负，若实际情况为狼 为-1，负负得正 没有撒谎 以此类推                if(v[k] * a[abs(v[k])]<0){                    lie.push_back(k);// 将撒谎情况记录下来                }            }            if (lie.size() == 2 && a[lie[0]] + a[lie[1]] == 0){                // 判断是否为题中要求的一狼一人                cout << i << ' ' << j;                return 0;            }        }    }    cout << "No Solution";    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>next_permutation实现版本</li></ol><pre class="line-numbers language-c++"><code class="language-c++">//// Created by masterCai on 2020/5/5.//#include <iostream>#include <vector>#include <algorithm>using namespace std;int main(){    int n;    cin >> n;    vector<int> statement(n+1); // 从1开始    for(int i = 1; i<=n; i++){        scanf("%d", &statement[i]);    }    vector<int> status = {-1, -1}; //从0开始    for(int i = 2; i<n; i++){        status.push_back(1);    }    do {        vector<int> lie;        for(int i = 1; i<=n; i++){            if(statement[i] * status[abs(statement[i])-1] < 0){                lie.push_back(i-1);            }        }        if (lie.size() == 2 && status[lie[0]]+status[lie[1]] == 0){            int cnt = 0;            for (int i = 0; i < n + 1; ++i) {                if(status[i] == -1){                    cnt == 0? printf("%d ", i+1):printf("%d", i+1);                    cnt += 1;                }            }            return 0;        }    } while (next_permutation(status.begin(), status.end()));    printf("No Solution");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题其实做了好久。。还只是第一题。。这个check函数在考试还是不太容易想出来，还是继续锤吧</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1148-Werewolf-Simple-Version&quot;&gt;&lt;a href=&quot;#1148-Werewolf-Simple-Version&quot; class=&quot;headerlink&quot; title=&quot;1148:Werewolf-Simple Version&quot;&gt;&lt;/a&gt;11
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="algorithm" scheme="http://blog.master-cai.xyz/tags/algorithm/"/>
    
      <category term="全排列" scheme="http://blog.master-cai.xyz/tags/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>1155_Heap_Paths</title>
    <link href="http://blog.master-cai.xyz/posts/26286.html"/>
    <id>http://blog.master-cai.xyz/posts/26286.html</id>
    <published>2020-05-04T13:12:45.000Z</published>
    <updated>2020-05-05T05:04:41.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1155-Heap-Paths"><a href="#1155-Heap-Paths" class="headerlink" title="1155:Heap Paths"></a><strong>1155</strong>:<strong>Heap Paths</strong></h2><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure))One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (1&lt;N≤1,000), the number of keys in the tree. Then the next line contains N distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree.Output Specification:For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.Finally print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all.Sample Input 1:898 72 86 60 65 12 23 50    Sample Output 1:98 86 2398 86 1298 72 6598 72 60 50Max Heap   Sample Input 2:88 38 25 58 52 82 70 60  Sample Output 2:8 25 708 25 828 38 528 38 58 60Min Heap  Sample Input 3:810 28 15 12 34 9 8 56Sample Output 3:10 15 810 15 910 28 3410 28 12 56Not Heap</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目虽然和堆有关系，但实际上只是一个深度搜索然后回溯就可以解决的问题。最开始的想法是在深搜的同时就判断一下是否满足条件，但是总是出一些奇怪的bug，递归的问题也不太好调试，就参照题解，先遍历出所有的路径情况，然后再单独判断是否符合条件。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++"><code class="language-c++">#include<iostream>#include<vector>using namespace std;int n;vector<int> heap; // 数组形式存储堆vector<int> path; // 存储路径 用于回溯void dfs(int pos){ // 回溯    if(pos >= n){        return;    }    if (pos >= n/2){ // 在数组堆中 大于n/2一定是叶子结点 打印结果即可        for(int i = 0; i<path.size(); i++){            printf("%d%c", path[i], i==path.size()-1?'\n': ' ');        }    } else{ // 不是叶子结点 继续遍历        int left = i*2+1;        int right = i*2+2;        // 下面是回溯 对于每一种可做的选择都进行尝试 相当于 for        path.push_back(heap[right]);        dfs(right);        path.pop_back();        path.push_back(heap[left]);        dfs(left);        path.pop_back();    }}int main(){    cin >> n;    for(int i=0; i<n; i++){        scanf("%d", &heap[i]);    }    path.push_back(heap[0]); // 根据dfs函数的逻辑 需要进行初始化    dfs(0);    bool min = true;    bool max = true;    for(int i = 0; i<n/2; i++){ //单独再判断是否符合条件        if ((i*2+1<n && heap[i]<heap[i*2+1]) || (i*2+2 < n && heap[i] < heap[i*2+2])){            max = false;        }        if ((i*2+1<n && heap[i]>heap[i*2+1]) || (i*2+2 < n && heap[i] > heap[i*2+2])){            min = false;        }    }    if(min){        printf("Min Heap");    } else if(max){        printf("Max Heap");    } else{        printf("Not Heap");    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1155-Heap-Paths&quot;&gt;&lt;a href=&quot;#1155-Heap-Paths&quot; class=&quot;headerlink&quot; title=&quot;1155:Heap Paths&quot;&gt;&lt;/a&gt;&lt;strong&gt;1155&lt;/strong&gt;:&lt;strong&gt;Heap Paths&lt;
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="algorithm" scheme="http://blog.master-cai.xyz/tags/algorithm/"/>
    
      <category term="堆" scheme="http://blog.master-cai.xyz/tags/%E5%A0%86/"/>
    
      <category term="深度搜索" scheme="http://blog.master-cai.xyz/tags/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>1154-vertex-coloring</title>
    <link href="http://blog.master-cai.xyz/posts/61450.html"/>
    <id>http://blog.master-cai.xyz/posts/61450.html</id>
    <published>2020-05-04T12:11:45.000Z</published>
    <updated>2020-05-04T13:05:44.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1154-vertex-coloring"><a href="#1154-vertex-coloring" class="headerlink" title="1154_vertex_coloring"></a>1154_vertex_coloring</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始做pat的题目了，题目感觉和leetcode还是区别比较大的，和蓝桥杯有一定的相似点。主要是对于输入输出的要求比较严格，我所报名的甲级是英文题目，其中部分单词还是不太熟悉，意思只能看靠猜测了，这方面还需要积累。关于语言方面，我觉得pat方面是有点坑的，它对于所有语言的时间要求是一样的，这对于用python（或者说非C++）选手来说很不友好。很简单的题目，用python语言实现和C++一样的算法，总是会有部分用例超时，所以我又被迫捡起了C++。但是好像目前各种机试的语言主要还是C++，也算是提前熟悉一下吧（有一般的报错是格式问题）。pat甲级目前题库一共有150+题目，感觉还是有希望熟悉一遍的（flag），其他的也不多说了，在家虽然没用那么舒服，还是要🐛🐛🐛。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>A proper vertex coloring is a labeling of the graph's vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most k colors is called a (proper) k-coloring.Now you are supposed to tell if a given coloring is a proper k-coloring.Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N and M (both no more than 10^4), being the total numbers of vertices and edges, respectively. Then M lines follow, each describes an edge by giving the indices (from 0 to N−1) of the two ends of the edge.After the graph, a positive integer K (≤ 100) is given, which is the number of colorings you are supposed to check. Then K lines follow, each contains N colors which are represented by non-negative integers in the range of int. The i-th color is the color of the i-th vertex.Output Specification:For each coloring, print in a line k-coloring if it is a proper k-coloring for some positive k, or No if not.Sample Input:10 118 76 84 58 48 11 21 49 89 11 02 440 1 0 1 4 1 0 1 3 00 1 0 1 4 1 0 1 0 08 1 0 1 4 1 0 5 3 01 2 3 4 5 6 7 8 8 9Sample Output:4-coloringNo6-coloringNo</code></pre><h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p>Vertex: 顶点</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>刚读到这个题目，一开始以为是一个图色问题，这方面还是不太熟悉。但是仔细读了一下，发现只需要判断一下就好了。一开始按照我的思路，我是用邻接表来存每条边，最后总是时间超时。参考了一下题解，发现题解直接存储了每条边。。其实这样效率更高，还是我把问题复杂化了。对于算法题来说，其实还是只要能够达到效果即可，不必要一定要复杂化问题。</p><p>本题的思路其实还是很简单，根据给出的每条边，对于其两个顶点，判断一下颜色是否相同即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++"><code class="language-c++">#include<iostream>#include<vector>#include<unordered_set>using namespace std;struct node{ //存储边    int x, y;};int main(){    int N, M;    cin >> N >> M;     vector<node> v(M); //存储所有的边    for(int i=0; i<M; ++i){ // 输入所有边的信息        scanf("%d %d", &v[i].x, &v[i].y);    }    int n;    scanf("%d", &n); // n种情况    for(int i=0; i<n; ++i){        // 对于每一种情况        unordered_set<int> s; // 使用set统计颜色数量        vector<int> a(N); // 存储每种图色方案        for(int j=0; j<N; j++){            scanf("%d", &a[j]);            s.insert(a[j]);        }        bool flag = true; //判断是否符合条件        for(int j = 0; j<M; ++j){             // 对于每条边的端点，进行判断            if(a[v[j].x]==a[v[j].y]){                flag = false;                break;            }        }        if(flag){            printf("%d-coloring\n", s.size());        }else{            printf("No\n");        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在做题中，其实还有一些小技巧，比如，使用scanf替代cin（cout同理）；不需要排序的时候，可以使用unordered_set和unorderd_map代替；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1154-vertex-coloring&quot;&gt;&lt;a href=&quot;#1154-vertex-coloring&quot; class=&quot;headerlink&quot; title=&quot;1154_vertex_coloring&quot;&gt;&lt;/a&gt;1154_vertex_coloring&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/categories/pat/"/>
    
    
      <category term="pat" scheme="http://blog.master-cai.xyz/tags/pat/"/>
    
      <category term="algorithm" scheme="http://blog.master-cai.xyz/tags/algorithm/"/>
    
      <category term="图" scheme="http://blog.master-cai.xyz/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>write-up 蓝桥杯2018省赛真题</title>
    <link href="http://blog.master-cai.xyz/posts/2547.html"/>
    <id>http://blog.master-cai.xyz/posts/2547.html</id>
    <published>2020-04-24T14:21:12.000Z</published>
    <updated>2020-05-04T13:05:44.303Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>write-up-蓝桥杯2020省赛一模</title>
    <link href="http://blog.master-cai.xyz/posts/44217.html"/>
    <id>http://blog.master-cai.xyz/posts/44217.html</id>
    <published>2020-04-21T14:13:27.000Z</published>
    <updated>2020-04-23T07:02:27.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="write-up-蓝桥杯2020省赛第一次模拟"><a href="#write-up-蓝桥杯2020省赛第一次模拟" class="headerlink" title="write-up 蓝桥杯2020省赛第一次模拟"></a>write-up 蓝桥杯2020省赛第一次模拟</h1><p>这次模拟赛题目比较常规，难度感觉不如前几年的省赛真题，前几题直接送分，只有后面三题是有一定难度。前六题比较无脑，就直接跳过了，从第七题开始分析。</p><h2 id="第七题-音节判断"><a href="#第七题-音节判断" class="headerlink" title="第七题 音节判断"></a>第七题 音节判断</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><pre><code>【问题描述】小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。【输入格式】输入一行，包含一个单词，单词中只包含小写英文字母。【输出格式】输出答案，或者为yes，或者为no。【样例输入】lanqiao【样例输出】yes【样例输入】world【样例输出】no【评测用例规模与约定】对于所有评测用例，单词中的字母个数不超过100。</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一开始拿到这个题想到的就是暴力枚举，直接搜索。看到题解后，发现有更加巧妙的方法：根据题目要求，如果将元音映射为1，辅音为0的话，那么符合条件的序列必然是“0..01..10..01..1”这样的。可以发现，这序列的特点就是01交替出现的情况只有三次。可以证明，只要不符合这个条件，不管多一次还是少一次，那么一定不符合题意。因此，我们只要在O（N）时间内判断这个情况就行。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    word <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>    l <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token string">'aeiou'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> word<span class="token punctuation">]</span>    <span class="token keyword">if</span> l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">or</span> l<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'no'</span><span class="token punctuation">)</span>        exit<span class="token punctuation">(</span><span class="token punctuation">)</span>    cnt <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> l<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>l<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            cnt <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'yes'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> cnt <span class="token operator">==</span> <span class="token number">3</span> <span class="token keyword">else</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'no'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题目其实也还算简单，因为题目指明了其数据量少于100，而一般来说，只要运算次数少于$10^8$，基本都可以在1s内解决，这个可以根据时间复杂度估算一下。在题解中，大量使用了生成器，简化了代码，不知道是否对性能有影响。另外代码中使用了exit函数退出程序，这个用法类似于C++ 中的<code>return 0</code>，但是在python的主函数中，无法通过return结束主进程，只能通过这种方式结束。另外，题解还有一种解法是我万万没有想到的，直接用re库匹配解题。。看来python库还有待开发。下面附上代码。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    word <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>    match <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'[^aeiou]+[aeiou]+[^aeiou]+[aeiou]+'</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'no'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> match <span class="token operator">==</span> None <span class="token operator">or</span> match<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第八题-长草"><a href="#第八题-长草" class="headerlink" title="第八题 长草"></a>第八题 长草</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><pre class="line-numbers language-【问题描述】"><code class="language-【问题描述】">小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。请告诉小明，k 个月后空地上哪些地方有草。【输入格式】输入的第一行包含两个整数 n, m。接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。接下来包含一个整数 k。【输出格式】输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。【样例输入】4 5.g..........g.......2【样例输出】gggg.gggg.ggggg.ggg.【评测用例规模与约定】对于 30% 的评测用例，2 <= n, m <= 20。对于 70% 的评测用例，2 <= n, m <= 100。对于所有评测用例，2 <= n, m <= 1000，1 <= k <= 1000。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这个题其实已经很经典了，在leetcode中也有这样的题目，其实就是bfs的一种变形，就是一种多源bfs搜索。一般的bfs只有一个起始原点，多源bfs就是将多个起始原点看作是一个超级原点，然后再进行扩散即可。大体过程和一般的bfs差异不大，也算是一个模版题。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    n<span class="token punctuation">,</span> m <span class="token operator">=</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        g<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    k <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    month <span class="token operator">=</span> <span class="token number">0</span>    q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'g'</span><span class="token punctuation">:</span>                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> q <span class="token operator">and</span> month <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>        new_q <span class="token operator">=</span> q<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> new_q<span class="token punctuation">:</span>            i<span class="token punctuation">,</span> j <span class="token operator">=</span> new_q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> d <span class="token keyword">in</span> dire<span class="token punctuation">:</span>                new_x <span class="token operator">=</span> i<span class="token operator">+</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                new_y <span class="token operator">=</span> j<span class="token operator">+</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> new_x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> new_x <span class="token operator">&lt;</span> n <span class="token operator">and</span> new_y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> new_y <span class="token operator">&lt;</span> m <span class="token operator">and</span> \                        g<span class="token punctuation">[</span>new_x<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    g<span class="token punctuation">[</span>new_x<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'g'</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>new_x<span class="token punctuation">,</span> new_y<span class="token punctuation">)</span><span class="token punctuation">)</span>        month <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">for</span> r <span class="token keyword">in</span> g<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第九题-序列计数"><a href="#第九题-序列计数" class="headerlink" title="第九题 序列计数"></a>第九题 序列计数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><pre><code>【问题描述】小明想知道，满足以下条件的正整数序列的数量：1. 第一项为 n；2. 第二项不超过 n；3. 从第三项开始，每一项小于前两项的差的绝对值。请计算，对于给定的 n，有多少种满足条件的序列。【输入格式】输入一行包含一个整数 n。【输出格式】输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。【样例输入】4【样例输出】7【样例说明】以下是满足条件的序列：4 14 1 14 1 24 24 2 14 34 4【评测用例规模与约定】对于 20% 的评测用例，1 &lt;= n &lt;= 5；对于 50% 的评测用例，1 &lt;= n &lt;= 10；对于 80% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 1000。</code></pre><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>刚拿到这道题，没有什么特别好的思路，就想着用暴力法来测一测，但是仔细考虑了一下，如果用暴力法枚举每种情况的话，时间复杂度是指数级的，肯定不可行。而且测评用例给的是1000个，也就是说最多可以用$O（n^2）$的算法来解决这个问题。看了一下题解，用的备忘录（dp）的方法来解决这个问题。memo数组的定义是        <code>memo[pre][cur]</code>, 表示上一个数是pre时，从<code>1...cur</code>的合法序列数量。因此，递推关系为</p><p><code>memo[pre][cur] = (1+dfs(pre, cur-1)+dfs(cur, abs(pre-cur)-1))</code></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sysMOD <span class="token operator">=</span> <span class="token number">10000</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">1001</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">]</span>sys<span class="token punctuation">.</span>Setrecursionlimit<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 修改递归层数限制 其实改为dp方式即可</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> cur <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">if</span> memo<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> memp<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span>    memo<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>pre<span class="token punctuation">,</span> cur<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>cur<span class="token punctuation">,</span> abs<span class="token punctuation">(</span>pre<span class="token operator">-</span>cur<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span>MOD    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    N <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>dfs<span class="token punctuation">(</span>N<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第十题-节目晚会单"><a href="#第十题-节目晚会单" class="headerlink" title="第十题 节目晚会单"></a>第十题 节目晚会单</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><pre><code>【问题描述】小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。小明发现，观众对于晚会的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。【输入格式】输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。第二行包含 n 个整数，依次为每个节目的好看值。【输出格式】输出一行包含 m 个整数，为选出的节目的好看值。【样例输入】5 33 1 2 5 4【样例输出】3 5 4【样例说明】选择了第1, 4, 5个节目。【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n &lt;= 20；对于 60% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。</code></pre><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这个题具有一定的误导性，第一次读题以为就两次排序就完事了，一看测试用例也符合，但是仔细一想，毕竟是最后一题，不太可能这么简单。仔细读题，发现题目要求了顺序不变，并且节目是尽可能好看，而不是最好看。因此，应该是区间范围内的最大值。那这个区间范围怎么选取？这样考虑问题：设节目为数组<code>s[n]</code>如果我们在前面尽量选择好看的节目，假设选择了一个并且位置稍微靠前的节目<code>s[i]</code>，那么为了凑齐m个节目，我们必须再从后面选取m-1个节目出来， 即选择<code>s[n-m+1:]</code>。整理一下思路，我们选择的过程就是对于第1个节目，我们选择的范围就是<code>s[0:n-m+1]</code>, 若选择出来的节目为i，第二个节目就是<code>s[i+1: n-m+1]</code>这个区间中进行选择，直到剩下的节目必须全选以凑够数量。这里就涉及到了一个多次区间查询的问题，可以用往期分析过的线段树做到$O(log_2^n)$复杂度的查询，这里用另一种思路，使用ST矩阵来做区间查询。</p><p>ST算法的本质其实是动态规划， 对于给定的序列，提前构建好dp数组，在查询时的时间复杂度为$O(1)$,而构建过程的时间复杂度是$O(nlog_2^N)$（这个思想类似于kmp算法，离线处理，在线查询）。</p><p>ST 算法的离线预处理过程非常巧妙，对于给定的序列<code>a[n]</code>, ST算法这样定义DP数组：<code>dp[i][j]</code>表示区间<code>a[i:i+2**j]</code>的最值。比如对于<code>dp[0][2]</code>，其表示区间范围是<code>a[0: 4]</code>。ST算法的状态转移思想是：对于区间<code>dp[i][j]</code>，首先将其分为两份，即<code>dp[i][j-1], dp[i+2**(j-1)][j-1]</code>，然后取这两者的最值即可。 由于这样特殊的定义，因此在查询一个区间的时候，也需要将区间按照2的次方进行分割。例如：对于区间<code>a[i: j]</code>，首先要将<code>j-i</code>取对数k，然后求<code>dp[i][k], dp[j-2**k][k]</code>的最值即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">MAX_N <span class="token operator">=</span> <span class="token number">100010</span> <span class="token comment" spellcheck="true"># dp数组的最大范围</span>MAX_POW <span class="token operator">=</span> <span class="token number">20</span> <span class="token comment" spellcheck="true"># 2的最大的次方数</span>N<span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>st <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>MAX_POW <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>MAX_N<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># dp数组</span>log <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>MAX_N<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 提前计算好log值 减小时间复杂度</span><span class="token keyword">def</span> <span class="token function">init_log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        log<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> log<span class="token punctuation">[</span>i<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token keyword">def</span> <span class="token function">init_st</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># dp过程</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>        st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token comment" spellcheck="true"># bast case 区间[i:i+1]的最值就是i本身</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> log<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 开始填表 遍历顺序是从左到右，从上到下</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token punctuation">(</span>j<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 由于下面需要访问i+(2**(j-1))，所以范围是N-(2(j-1)), 实际上是把0到N都遍历了的。</span>            idx1<span class="token punctuation">,</span> idx2 <span class="token operator">=</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> st<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token punctuation">(</span>j<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 先取出下表</span>            st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> idx1 <span class="token keyword">if</span> data<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span> <span class="token operator">>=</span> data<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span> <span class="token keyword">else</span> idx2 <span class="token comment" spellcheck="true"># 根据题意 取最大值</span><span class="token keyword">def</span> <span class="token function">query</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    length <span class="token operator">=</span> l <span class="token operator">-</span> r <span class="token operator">+</span> <span class="token number">1</span>    k <span class="token operator">=</span> log<span class="token punctuation">[</span>length<span class="token punctuation">]</span>    idx1<span class="token punctuation">,</span> idx2 <span class="token operator">=</span> st<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> st<span class="token punctuation">[</span>r<span class="token number">-2</span><span class="token operator">**</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token keyword">return</span> idx1 <span class="token keyword">if</span> data<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span> <span class="token operator">>=</span> data<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span> <span class="token keyword">else</span> idx2<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    N<span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    data <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    init_log<span class="token punctuation">(</span><span class="token punctuation">)</span>    init_st<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    pos_max<span class="token punctuation">,</span> pos_1<span class="token punctuation">,</span> pos_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">-</span>M <span class="token comment" spellcheck="true"># 初始化查询范围 有点类似滑动窗口的意思</span>    <span class="token keyword">while</span> pos_1 <span class="token operator">&lt;</span> pos_2 <span class="token operator">&lt;</span> N<span class="token punctuation">:</span>        pos_max <span class="token operator">=</span> query<span class="token punctuation">(</span>data<span class="token punctuation">,</span> pos1<span class="token punctuation">,</span> pos2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 当前范围内的最大值位置</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>pos_max<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>        pos_1<span class="token punctuation">,</span> pos_2 <span class="token operator">=</span> pos_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> pos_2<span class="token operator">+</span><span class="token number">1</span>         <span class="token comment" spellcheck="true"># 左端点从最大值下一个开始，右端点+1 这里可以将左右端点看成一个区间 也可以将右端点到末尾看        # 成一个区间 右端点控制的是这一区间的长度</span>    <span class="token keyword">while</span> pos_2 <span class="token operator">!=</span> N<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 节目没有选慢 剩下的就必须全选</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>pos_2<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>        pos_2 <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一次的省赛模拟题感觉难度没有往年真题难，好像去年的模拟题也是这样一个难度的，但是还是学到了一些东西。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;write-up-蓝桥杯2020省赛第一次模拟&quot;&gt;&lt;a href=&quot;#write-up-蓝桥杯2020省赛第一次模拟&quot; class=&quot;headerlink&quot; title=&quot;write-up 蓝桥杯2020省赛第一次模拟&quot;&gt;&lt;/a&gt;write-up 蓝桥杯2020省
      
    
    </summary>
    
    
      <category term="蓝桥杯" scheme="http://blog.master-cai.xyz/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="write-up" scheme="http://blog.master-cai.xyz/tags/write-up/"/>
    
      <category term="蓝桥杯" scheme="http://blog.master-cai.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>mac环境下下载并播放blob视频</title>
    <link href="http://blog.master-cai.xyz/posts/37450.html"/>
    <id>http://blog.master-cai.xyz/posts/37450.html</id>
    <published>2020-04-16T10:36:21.000Z</published>
    <updated>2020-04-17T01:12:21.563Z</updated>
    
    <content type="html"><![CDATA[<p>今天想下载一个tx的视频，像往常一样，在chrome下打开，f12调出控制台，定位到视频所在位置，复制url，跳转到url..结果404 not found。仔细一看，这个视频url是这样的<code>blob:https://xxxx</code>。摸鱼20年，从来没见过这样的协议，但是它确实是在视频的<code>src</code>属性上，应该就是了。直接去掉blob前缀，依然无效。然后搜索了一下blob到底是个什么东西。</p><p>blob:https并不是一种协议，而是html5中blob对象在赋给video标签后生成的一串标记，blob对象包含的数据，浏览器内部会解析。直白一点的理解就是，网站将视频链接给隐藏了。对此，解决的办法就是直接在media中查看加载的视频文件。</p><p>本以为到这里就可以下载视频了，但是，打开media后，并没有任何内容，而页面上视频却正确的加载并播放了。考虑到长视频可能是使用了xhr，我又查看了一下xhr文件，果然有。但是却是一堆的文件。细看是ts文件，说明视频网站将视频资源分段了，又搜索了一下发现这是一种新的协议，m3u8。</p><p>m3u8是苹果公司推出的视频播放标准，是m3u的一种，只是编码格式采用的是UTF-8。m3u8准确来说是一种索引文件，使用m3u8文件实际上是通过它来解析对应的放在服务器上的视频网络地址，从而实现在线播放。使用m3u8格式文件主要因为可以实现多码率视频的适配，视频网站可以根据用户的网络带宽情况，自动为客户端匹配一个合适的码率文件进行播放，从而保证视频的流畅度。</p><p>因此，我们只要找到m3u8文件就可以了。一番搜索，我发现了m3u8文件，并且还对应着不同的清晰度。选择了一个m3u8文件下载后，打开发现里面确实都是ts文件的链接，应该就是将整个视频分段了。m3u8文件又应该如何下载。</p><p>再次Google，发现了两个工具：ffmpeg和vlc播放器。</p><p>ffmpeg是一个命令行工具，是视频处理最常用的开源软件，它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p><p>具体用法不多介绍，简单说一下：ffmpeg命令为5个参数 <code>ffmpeg {1} {2} -i {3} {4} {5}</code></p><p>1是全局参数， 2是输入文件参数， 3是输入文件， 4是输出参数，5是输出文件。ffmpeg可以直接下载m3u8文件的视频，只需要用以下命令<code>ffmpeg -i x.m3u8 x.ts</code>即可自动下载m3u8播放列表中的视频并拼接。但是实际使用中并未成功。另一个用法是用ffmpeg对ts格式进行转码：<code>ffmpeg -y -i x.ts -c:v libx264 -c:a copy -bsf:a aac_adtstoasc x.mp4</code>。使用此命令对下载的ts文件进行转码也出现错误。。。可能是我打开方式不太正确。</p><p>然后说一下vlc播放器。vlc播放器可以直接加载m3u8文件进行播放，如需下载，只需要在导入url时设置一下即可，这也是我目前成功的一种方法。</p><p>还有一种比较方便的方法可以直接下载m3u8视频。使用chrome插件，HDS-HLS-Video-Downloader，可直接捕获网页中的m3u8文件进行下载（虽然下载后的ts视频无法播放）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天想下载一个tx的视频，像往常一样，在chrome下打开，f12调出控制台，定位到视频所在位置，复制url，跳转到url..结果404 not found。仔细一看，这个视频url是这样的&lt;code&gt;blob:https://xxxx&lt;/code&gt;。摸鱼20年，从来没见过
      
    
    </summary>
    
    
      <category term="技巧" scheme="http://blog.master-cai.xyz/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Mac" scheme="http://blog.master-cai.xyz/tags/Mac/"/>
    
      <category term="摸鱼" scheme="http://blog.master-cai.xyz/tags/%E6%91%B8%E9%B1%BC/"/>
    
      <category term="爬虫" scheme="http://blog.master-cai.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="技巧" scheme="http://blog.master-cai.xyz/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法整理</title>
    <link href="http://blog.master-cai.xyz/posts/32294.html"/>
    <id>http://blog.master-cai.xyz/posts/32294.html</id>
    <published>2020-04-14T03:26:03.474Z</published>
    <updated>2020-04-17T01:12:21.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十大排序算法整理"><a href="#十大排序算法整理" class="headerlink" title="十大排序算法整理"></a>十大排序算法整理</h1><h2 id="总体分类"><a href="#总体分类" class="headerlink" title="总体分类"></a>总体分类</h2><p>首先解释一个概念，算法的稳定性：指序列中两相同的相邻元素在两趟排序的过程中相对位置是否发生改变，不改变为稳定的排序算法。</p><p>根据这个概念，我们可以对排序算法进行分类：</p><ol><li>稳定的排序算法：插入排序，冒泡排序， 归并排序， 基数排序，计数排序，桶排序</li><li>不稳定的排序算法；选择排序， 希尔排序， 快速排序， 堆排序</li></ol><p>再根据算法的时间复杂度，我们可以再对算法进行一次排序：</p><ol><li>$O(n^2)$:插入排序， 选择排序，冒泡排序</li><li>$O(nlog_2(n))$:快速排序，归并排序，堆排序</li><li>$O(n^ {1+§}), 0≤§≤1$:希尔排序</li><li>$O(n)$:基数排序，计数排序，桶排序</li></ol><p>下面对上述十种常用算法一一分析。</p><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>先从最简单的选择排序开始，这个算法的思想没有什么好说的，就是每一趟从未排序的序列中选出一个最大（小）值，然后放在序列末尾即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        max_idx <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>max_idx<span class="token punctuation">]</span><span class="token punctuation">:</span>                max_idx <span class="token operator">=</span> j        arr<span class="token punctuation">[</span>max_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>max_idx<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>插入排序的思路也很直观，将序列分为排序和未排序的部分，每次从未排序的部分中选择一个，插入到已排序的序列中的合适的位置即可。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># a[0]视为已排序序列</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># arr[i]是未排序序列中选取的那个 arr[j]是已排列的序列</span>                arr<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>j<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                arr<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>希尔排序是对插入排序的一种改进。插入排序对于完全有序的序列效率最高，对于完全无序的序列效率最低。希尔排序的思想就是先让序列部分有序，然后再进行插入排序，以此提高效率。为此，希尔排序中设计了增量的概念（个人理解就是分组大小），这个序列也不是随便选择的。希尔排序中使用的序列是${1, 4, 13, …, a_{n-1}*3+1}$，为什么不能使用如{1, 2, 4, 8}或其他的序列呢？因为希尔排序的复杂度是和增量序列的选择有关系的，经过数学证明，最好的一个序列为1，4， 13这样的序列。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    gap <span class="token operator">=</span> <span class="token number">1</span>     n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">while</span> gap <span class="token operator">&lt;</span> n<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 动态生成间隔序列</span>        gap <span class="token operator">=</span> gap<span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">while</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 间隔为1即为对整体进行插入排序</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>gap<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 将arr[0,gap,gap*2,..]分为一组 开始元素分别为0,1,gap-1</span>            tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 当前分组第i//gap个元素</span>            j <span class="token operator">=</span> i<span class="token operator">-</span>gap <span class="token comment" spellcheck="true"># 当前序列的逻辑索引 gap在逻辑上等于‘1’ 即 j=i-1 即j为arr[i]的上个元素 </span>            <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 升序排列 尽量将小元素向前排列</span>            <span class="token comment" spellcheck="true"># 插入排序 当tmp较小时，需要向前插入 这里是将arr[j]向后移动一位，为tmp插入做准备 </span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> gap <span class="token comment" spellcheck="true"># 此处的插入排序为倒序遍历</span>            arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp <span class="token comment" spellcheck="true"># 确定插入位置后 在此处插入</span>        gap <span class="token operator">=</span> gap<span class="token operator">//</span><span class="token number">3</span> <span class="token comment" spellcheck="true"># 缩小gap值，最终退化为插入排序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希尔排序中有一点不好理解的是，在排序过程中，每个单独的子序列并不是一次性排序完成的，而是按照原序列的顺序，一步一步的排序完成的。举个例子，若arr[i]属于子序列s1，当s1排序了一步后，总的序列将遍历到arr[i+1]（属于s2），此时则继续对s2进行插入排序。直到最后一个gap，主序列（外层循环）每推进1，就会完成一个子序列的插入排序。个人认为将每个子序列单独出来，完全排序完成后再处理下一个序列也是可行的，但是网络上见到的大多数希尔排序都是这样实现的，可能和性能有关？</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>冒泡排序也是一种非常常见的排序方法，每次比较两个元素，如果顺序错误就将其翻转。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>归并排序是使用分治思想的一个经典的算法。算法的主要思想就是将长序列化短，短序列化元，元序列（单个元素）自身看作有序，然后再进行合并即可。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> arr    m <span class="token operator">=</span> n<span class="token operator">//</span><span class="token number">2</span>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> merge<span class="token punctuation">(</span>merge_sort<span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> merge_sort<span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>    l<span class="token punctuation">,</span> L <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>left<span class="token punctuation">)</span>    r<span class="token punctuation">,</span> R <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>right<span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> L <span class="token operator">and</span> r <span class="token operator">&lt;</span> R<span class="token punctuation">:</span>        <span class="token keyword">if</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>            l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            r <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> l <span class="token operator">&lt;</span> L<span class="token punctuation">:</span>        res <span class="token operator">+=</span> left    <span class="token keyword">if</span> r <span class="token operator">&lt;</span> R<span class="token punctuation">:</span>        res <span class="token operator">+=</span> right    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>快速排序使用的也是一种分治的思想。正如名称，快速排序的实际表现比大多数复杂同为$O(nlog_2(n))$的算法更加高效。本质上看，快速排序是在冒泡排序的基础上的递归分治。算法的思想是首先从序列中选出一个元素作为“pivot”，将所有小于pivot的元素放在其左边，大于pivot的放在其右边。对于pivot左右两边，再递归的重复上述操作即可。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token operator">=</span>None<span class="token punctuation">,</span> right<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        m <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span>    i <span class="token operator">=</span> l    j <span class="token operator">=</span> r    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>        <span class="token keyword">while</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> x <span class="token operator">and</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">while</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x <span class="token operator">and</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span>    <span class="token keyword">return</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>堆排序是利用了堆这种数据结构来进行。这里是将序列构建为一个大（小）根堆，然后每次将堆顶的元素与</p><p>堆尾交换。然后将堆的大小减小1，重新构建堆。多次重复上述过程，即可完成排序。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">build_max_heap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        heapity<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>    left <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span>    right <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span>    largest <span class="token operator">=</span> i    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> arrLen <span class="token operator">and</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>        largest <span class="token operator">=</span> left    <span class="token keyword">if</span> right <span class="token operator">&lt;</span> arrLen <span class="token operator">and</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>        largest <span class="token operator">=</span> right    <span class="token keyword">if</span> largest <span class="token operator">!=</span> i<span class="token punctuation">:</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> arrLen    arrLen <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    build_max_heap<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        arrLen <span class="token operator">-=</span> <span class="token number">1</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>计数排序的原理是将序列中的数值都映射到额外的计数数组中去，当计数完成后，排序也完成了，只要按照所需的顺序复原立刻。计数排序要求序列中的值最大不能超过<code>max_value</code></p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    max_value <span class="token operator">=</span> <span class="token number">10000</span>    cnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>max_value    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        cnt<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>max_value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>            cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>桶排序是计数排序的一种更加通用的形式，他的原理是利用一个hash函数将序列中的元素映射到各个桶中去，然后再对桶中元素进行排序。当每个元素都均匀的分到每个桶中时，效率最高（极端情况退化为计数排序）。反之，所有元素都分配到同一个桶中的时候，效率最低。因此，桶排序的效率和hash函数有很大的关联。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bucket_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> bucketSize<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 默认桶的大小为5 越大越好</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> arr    max_value <span class="token operator">=</span> max<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>     min_value <span class="token operator">=</span> min<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    bucketCnt <span class="token operator">=</span> <span class="token punctuation">(</span>max_value<span class="token operator">-</span>min_value<span class="token punctuation">)</span><span class="token operator">//</span>bucketSize<span class="token operator">+</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 计算需要多少桶</span>    buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>bucketCnt<span class="token punctuation">)</span><span class="token punctuation">]</span>     <span class="token comment" spellcheck="true"># 此处即为hash函数的实现 f(arr[i])=(arr[i]-min_value)//bucketSize 可设计不同函数</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        buckets<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>min_value<span class="token punctuation">)</span><span class="token operator">//</span>bucketSize<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 对每个桶内的元素进行排列</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>bucketCnt<span class="token punctuation">)</span><span class="token punctuation">:</span>        insert_sort<span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 此处直接调用插入排序</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 将排序后的结果写到arr中作为结果</span>    <span class="token keyword">return</span> arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>基数排序是一种非比较型的整数排序算法，其原理是将整数按照位分割，然后对应每个位进行比较，比如说，同时比较所有数的个位，然后是十位，以此类推，这里同样运用了桶的概念。基数排序的桶是固定的，将0～9作为桶，每次都按照不同位将数字映射到这些桶中，以达到排序的目的。可以说基数排序是一种特殊的桶排序。</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">radix_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    digit <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 记录当前排序到第几位</span>    max_digit <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 记录最大位数</span>    max_value <span class="token operator">=</span> max<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token number">10</span><span class="token operator">**</span>max_digit <span class="token operator">&lt;</span> max_value<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 计算最大位数</span>        max_digit <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">while</span> digit <span class="token operator">&lt;</span> max_digit<span class="token punctuation">:</span>        tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 对每一位 进行一次桶排序</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">:</span>             t <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">10</span><span class="token operator">**</span>digit<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span> <span class="token comment" spellcheck="true"># 此处为该桶排序的hash函数 较为特殊</span>            tmp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        col <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> bucket <span class="token keyword">in</span> tmp<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 统计当前位的排序结果 基于此对下一位进行排序 达到整体排序的目的</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> bucket<span class="token punctuation">:</span>                col<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        arr <span class="token operator">=</span> col        digit <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;十大排序算法整理&quot;&gt;&lt;a href=&quot;#十大排序算法整理&quot; class=&quot;headerlink&quot; title=&quot;十大排序算法整理&quot;&gt;&lt;/a&gt;十大排序算法整理&lt;/h1&gt;&lt;h2 id=&quot;总体分类&quot;&gt;&lt;a href=&quot;#总体分类&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python常用库之collections与itertools</title>
    <link href="http://blog.master-cai.xyz/posts/8852.html"/>
    <id>http://blog.master-cai.xyz/posts/8852.html</id>
    <published>2020-03-27T09:51:39.000Z</published>
    <updated>2020-04-04T02:51:38.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python常用库之collections与itertools"><a href="#python常用库之collections与itertools" class="headerlink" title="python常用库之collections与itertools"></a>python常用库之collections与itertools</h1><p>最近看题解的时候发现好多问题可以直接使用内置库函数解决，及优雅又高效（开挂实锤）。下面依次来介绍这两个包的常见用法。</p><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p><code>collections</code>是Python内建的一个集合模块，提供了许多有用的集合类，这个模块实现了特定目标的容器，以提供Python标准内建容器 dict, list, set, 和 tuple的替代选择。相关连接：<a href="https://docs.python.org/zh-cn/3/library/collections.html" target="_blank" rel="noopener">官方文档</a>， <a href="https://www.kancloud.cn/smilesb101/python3_x/298822" target="_blank" rel="noopener">廖雪峰的python3教程</a>。</p><h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>这个是对tuple的扩展，<code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。用例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple<span class="token comment" spellcheck="true"># namedtuple('名称', [属性list]):</span><span class="token operator">>></span><span class="token operator">></span> Point <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Point'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>x<span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>y<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>namedtuple主要用于快速声明一个自定义tuple，避免创建class（完全可以用class代替）。其他具体用法见官方文档。</p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>在python中，数组对应着list。使用<code>list</code>存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为<code>list</code>是线性存储，数据量大的时候，插入和删除效率很低。<code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> qdeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Deque队列是由栈或者queue队列生成的（发音是 “deck”，”double-ended queue”的简称）。Deque 支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。虽然 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 对象也支持类似操作，不过这里优化了定长操作和 <code>pop(0)</code> 和 <code>insert(0, v)</code> 的开销。它们引起 O(n) 内存移动的操作，改变底层数据表达的大小和位置。<code>deque</code>除了实现<code>list</code>的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p><p>如果 <em>maxlen</em> 没有指定或者是 <code>None</code> ，deques 可以增长到任意长度。否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出。限定长度deque提供类似Unix filter <code>tail</code> 的功能。它们同样可以用与追踪最近的交换和其他数据池活动。</p><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>。defaultdict接受一个类型（其实是函数)作为输入，当访问的键不存在时，普通的dict会报错，而defaultdict就会自动创建该键并给出设定的类型的默认值。</p><p>eg1：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> s<span class="token punctuation">:</span>        d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 每个键在初次访问时都不存在，defaultdict会创建并默认给一个默认值（这里是[]),即d[k]为list</span><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>eg2：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token operator">>></span><span class="token operator">></span> dd <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token keyword">lambda</span><span class="token punctuation">:</span> <span class="token string">'N/A'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> dd<span class="token punctuation">[</span><span class="token string">'key1'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token operator">>></span><span class="token operator">></span> dd<span class="token punctuation">[</span><span class="token string">'key1'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># key1存在</span><span class="token string">'abc'</span><span class="token operator">>></span><span class="token operator">></span> dd<span class="token punctuation">[</span><span class="token string">'key2'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># key2不存在，返回默认值</span><span class="token string">'N/A'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里传入的参数就是一个函数，默认返回“N/A”。</p><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>使用<code>dict</code>时，<code>Key</code>是无序的。在对<code>dict</code>做迭代时，我们无法确定<code>Key</code>的顺序。如果要保持<code>Key</code>的顺序，可以用<code>OrderedDict</code>。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> OrderedDict<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d <span class="token comment" spellcheck="true"># dict的Key是无序的</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> od <span class="token operator">=</span> OrderedDict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> od <span class="token comment" spellcheck="true"># OrderedDict的Key是有序的</span>OrderedDict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，orderedDict中key的顺序是输入的顺序，并不是键值本身的顺序。另外有序字典的 <a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.OrderedDict.popitem" target="_blank" rel="noopener"><code>popitem()</code></a> 方法移除并返回一个 (key, value) 键值对。 如果 <em>last</em> 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对（默认为True)。</p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> Counter<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token string">'programming'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> cCounter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'g'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'p'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用处比较多，可以快速统计元素个数。输入参数是一个 <em>iterable</em> 被计数或其他的 <em>mapping</em> (or counter)：即可。</p><p>需要注意的是：设置一个计数为0不会从计数器中移去一个元素。使用 <code>del</code> 来删除它，Counter对象有一个字典接口，如果引用的键没有任何记录，就返回一个0，而不是弹出一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 。</p><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><p>Python的内建模块<code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p><h3 id="无限迭代器"><a href="#无限迭代器" class="headerlink" title="无限迭代器"></a>无限迭代器</h3><p>无限迭代器创建一个迭代器，它从 <em>start</em> 值开始，返回均匀间隔的值。常用于 <a href="https://docs.python.org/zh-cn/3/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 中的实参来生成连续的数据点。此外，还用于 <a href="https://docs.python.org/zh-cn/3/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a> 来添加序列号。<code>itertools.count(start=0, step=1)</code>, </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python常用库之collections与itertools&quot;&gt;&lt;a href=&quot;#python常用库之collections与itertools&quot; class=&quot;headerlink&quot; title=&quot;python常用库之collections与itertool
      
    
    </summary>
    
    
      <category term="python" scheme="http://blog.master-cai.xyz/categories/python/"/>
    
    
      <category term="python" scheme="http://blog.master-cai.xyz/tags/python/"/>
    
      <category term="常用库" scheme="http://blog.master-cai.xyz/tags/%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
  </entry>
  
</feed>
