<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>write-up-蓝桥杯2020省赛一模</title>
      <link href="/posts/44217.html"/>
      <url>/posts/44217.html</url>
      
        <content type="html"><![CDATA[<h1 id="write-up-蓝桥杯2020省赛第一次模拟"><a href="#write-up-蓝桥杯2020省赛第一次模拟" class="headerlink" title="write-up 蓝桥杯2020省赛第一次模拟"></a>write-up 蓝桥杯2020省赛第一次模拟</h1><p>这次模拟赛题目比较常规，难度感觉不如前几年的省赛真题，前几题直接送分，只有后面三题是有一定难度。前六题比较无脑，就直接跳过了，从第七题开始分析。</p><h2 id="第七题-音节判断"><a href="#第七题-音节判断" class="headerlink" title="第七题 音节判断"></a>第七题 音节判断</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><pre><code>【问题描述】小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。【输入格式】输入一行，包含一个单词，单词中只包含小写英文字母。【输出格式】输出答案，或者为yes，或者为no。【样例输入】lanqiao【样例输出】yes【样例输入】world【样例输出】no【评测用例规模与约定】对于所有评测用例，单词中的字母个数不超过100。</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一开始拿到这个题想到的就是暴力枚举，直接搜索。看到题解后，发现有更加巧妙的方法：根据题目要求，如果将元音映射为1，辅音为0的话，那么符合条件的序列必然是“0..01..10..01..1”这样的。可以发现，这序列的特点就是01交替出现的情况只有三次。可以证明，只要不符合这个条件，不管多一次还是少一次，那么一定不符合题意。因此，我们只要在O（N）时间内判断这个情况就行。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    word <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>    l <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token string">'aeiou'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> word<span class="token punctuation">]</span>    <span class="token keyword">if</span> l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">or</span> l<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'no'</span><span class="token punctuation">)</span>        exit<span class="token punctuation">(</span><span class="token punctuation">)</span>    cnt <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> l<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>l<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            cnt <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'yes'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> cnt <span class="token operator">==</span> <span class="token number">3</span> <span class="token keyword">else</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'no'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题目其实也还算简单，因为题目指明了其数据量少于100，而一般来说，只要运算次数少于$10^8$，基本都可以在1s内解决，这个可以根据时间复杂度估算一下。在题解中，大量使用了生成器，简化了代码，不知道是否对性能有影响。另外代码中使用了exit函数退出程序，这个用法类似于C++ 中的<code>return 0</code>，但是在python的主函数中，无法通过return结束主进程，只能通过这种方式结束。另外，题解还有一种解法是我万万没有想到的，直接用re库匹配解题。。看来python库还有待开发。下面附上代码。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    word <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>    match <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'[^aeiou]+[aeiou]+[^aeiou]+[aeiou]+'</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'no'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> match <span class="token operator">==</span> None <span class="token operator">or</span> match<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第八题-长草"><a href="#第八题-长草" class="headerlink" title="第八题 长草"></a>第八题 长草</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><pre class="line-numbers language-【问题描述】"><code class="language-【问题描述】">小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。请告诉小明，k 个月后空地上哪些地方有草。【输入格式】输入的第一行包含两个整数 n, m。接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。接下来包含一个整数 k。【输出格式】输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。【样例输入】4 5.g..........g.......2【样例输出】gggg.gggg.ggggg.ggg.【评测用例规模与约定】对于 30% 的评测用例，2 <= n, m <= 20。对于 70% 的评测用例，2 <= n, m <= 100。对于所有评测用例，2 <= n, m <= 1000，1 <= k <= 1000。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这个题其实已经很经典了，在leetcode中也有这样的题目，其实就是bfs的一种变形，就是一种多源bfs搜索。一般的bfs只有一个起始原点，多源bfs就是将多个起始原点看作是一个超级原点，然后再进行扩散即可。大体过程和一般的bfs差异不大，也算是一个模版题。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    n<span class="token punctuation">,</span> m <span class="token operator">=</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        g<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    k <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    month <span class="token operator">=</span> <span class="token number">0</span>    q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'g'</span><span class="token punctuation">:</span>                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> q <span class="token operator">and</span> month <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>        new_q <span class="token operator">=</span> q<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> new_q<span class="token punctuation">:</span>            i<span class="token punctuation">,</span> j <span class="token operator">=</span> new_q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> d <span class="token keyword">in</span> dire<span class="token punctuation">:</span>                new_x <span class="token operator">=</span> i<span class="token operator">+</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                new_y <span class="token operator">=</span> j<span class="token operator">+</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> new_x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> new_x <span class="token operator">&lt;</span> n <span class="token operator">and</span> new_y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> new_y <span class="token operator">&lt;</span> m <span class="token operator">and</span> \                        g<span class="token punctuation">[</span>new_x<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    g<span class="token punctuation">[</span>new_x<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'g'</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>new_x<span class="token punctuation">,</span> new_y<span class="token punctuation">)</span><span class="token punctuation">)</span>        month <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">for</span> r <span class="token keyword">in</span> g<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第九题-序列计数"><a href="#第九题-序列计数" class="headerlink" title="第九题 序列计数"></a>第九题 序列计数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><pre><code>【问题描述】小明想知道，满足以下条件的正整数序列的数量：1. 第一项为 n；2. 第二项不超过 n；3. 从第三项开始，每一项小于前两项的差的绝对值。请计算，对于给定的 n，有多少种满足条件的序列。【输入格式】输入一行包含一个整数 n。【输出格式】输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。【样例输入】4【样例输出】7【样例说明】以下是满足条件的序列：4 14 1 14 1 24 24 2 14 34 4【评测用例规模与约定】对于 20% 的评测用例，1 &lt;= n &lt;= 5；对于 50% 的评测用例，1 &lt;= n &lt;= 10；对于 80% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 1000。</code></pre><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>刚拿到这道题，没有什么特别好的思路，就想着用暴力法来测一测，但是仔细考虑了一下，如果用暴力法枚举每种情况的话，时间复杂度是指数级的，肯定不可行。而且测评用例给的是1000个，也就是说最多可以用$O（n^2）$的算法来解决这个问题。看了一下题解，用的备忘录（dp）的方法来解决这个问题。memo数组的定义是        <code>memo[pre][cur]</code>, 表示上一个数是pre时，从<code>1...cur</code>的合法序列数量。因此，递推关系为</p><p><code>memo[pre][cur] = (1+dfs(pre, cur-1)+dfs(cur, abs(pre-cur)-1))</code></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sysMOD <span class="token operator">=</span> <span class="token number">10000</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">1001</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">]</span>sys<span class="token punctuation">.</span>Setrecursionlimit<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 修改递归层数限制 其实改为dp方式即可</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> cur <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">if</span> memo<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> memp<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span>    memo<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>pre<span class="token punctuation">,</span> cur<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>cur<span class="token punctuation">,</span> abs<span class="token punctuation">(</span>pre<span class="token operator">-</span>cur<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span>MOD    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    N <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>dfs<span class="token punctuation">(</span>N<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第十题-节目晚会单"><a href="#第十题-节目晚会单" class="headerlink" title="第十题 节目晚会单"></a>第十题 节目晚会单</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><pre><code>【问题描述】小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。小明发现，观众对于晚会的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。【输入格式】输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。第二行包含 n 个整数，依次为每个节目的好看值。【输出格式】输出一行包含 m 个整数，为选出的节目的好看值。【样例输入】5 33 1 2 5 4【样例输出】3 5 4【样例说明】选择了第1, 4, 5个节目。【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n &lt;= 20；对于 60% 的评测用例，1 &lt;= n &lt;= 100；对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。</code></pre><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这个题具有一定的误导性，第一次读题以为就两次排序就完事了，一看测试用例也符合，但是仔细一想，毕竟是最后一题，不太可能这么简单。仔细读题，发现题目要求了顺序不变，并且节目是尽可能好看，而不是最好看。因此，应该是区间范围内的最大值。那这个区间范围怎么选取？这样考虑问题：设节目为数组<code>s[n]</code>如果我们在前面尽量选择好看的节目，假设选择了一个并且位置稍微靠前的节目<code>s[i]</code>，那么为了凑齐m个节目，我们必须再从后面选取m-1个节目出来， 即选择<code>s[n-m+1:]</code>。整理一下思路，我们选择的过程就是对于第1个节目，我们选择的范围就是<code>s[0:n-m+1]</code>, 若选择出来的节目为i，第二个节目就是<code>s[i+1: n-m+1]</code>这个区间中进行选择，直到剩下的节目必须全选以凑够数量。这里就涉及到了一个多次区间查询的问题，可以用往期分析过的线段树做到$O(log_2^n)$复杂度的查询，这里用另一种思路，使用ST矩阵来做区间查询。</p><p>ST算法的本质其实是动态规划， 对于给定的序列，提前构建好dp数组，在查询时的时间复杂度为$O(1)$,而构建过程的时间复杂度是$O(nlog_2^N)$（这个思想类似于kmp算法，离线处理，在线查询）。</p><p>ST 算法的离线预处理过程非常巧妙，对于给定的序列<code>a[n]</code>, ST算法这样定义DP数组：<code>dp[i][j]</code>表示区间<code>a[i:i+2**j]</code>的最值。比如对于<code>dp[0][2]</code>，其表示区间范围是<code>a[0: 4]</code>。ST算法的状态转移思想是：对于区间<code>dp[i][j]</code>，首先将其分为两份，即<code>dp[i][j-1], dp[i+2**(j-1)][j-1]</code>，然后取这两者的最值即可。 由于这样特殊的定义，因此在查询一个区间的时候，也需要将区间按照2的次方进行分割。例如：对于区间<code>a[i: j]</code>，首先要将<code>j-i</code>取对数k，然后求<code>dp[i][k], dp[j-2**k][k]</code>的最值即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">MAX_N <span class="token operator">=</span> <span class="token number">100010</span> <span class="token comment" spellcheck="true"># dp数组的最大范围</span>MAX_POW <span class="token operator">=</span> <span class="token number">20</span> <span class="token comment" spellcheck="true"># 2的最大的次方数</span>N<span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>st <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>MAX_POW <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>MAX_N<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># dp数组</span>log <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>MAX_N<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 提前计算好log值 减小时间复杂度</span><span class="token keyword">def</span> <span class="token function">init_log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        log<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> log<span class="token punctuation">[</span>i<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token keyword">def</span> <span class="token function">init_st</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># dp过程</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>        st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token comment" spellcheck="true"># bast case 区间[i:i+1]的最值就是i本身</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> log<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 开始填表 遍历顺序是从左到右，从上到下</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token punctuation">(</span>j<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 由于下面需要访问i+(2**(j-1))，所以范围是N-(2(j-1)), 实际上是把0到N都遍历了的。</span>            idx1<span class="token punctuation">,</span> idx2 <span class="token operator">=</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> st<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token punctuation">(</span>j<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 先取出下表</span>            st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> idx1 <span class="token keyword">if</span> data<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span> <span class="token operator">>=</span> data<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span> <span class="token keyword">else</span> idx2 <span class="token comment" spellcheck="true"># 根据题意 取最大值</span><span class="token keyword">def</span> <span class="token function">query</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    length <span class="token operator">=</span> l <span class="token operator">-</span> r <span class="token operator">+</span> <span class="token number">1</span>    k <span class="token operator">=</span> log<span class="token punctuation">[</span>length<span class="token punctuation">]</span>    idx1<span class="token punctuation">,</span> idx2 <span class="token operator">=</span> st<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> st<span class="token punctuation">[</span>r<span class="token number">-2</span><span class="token operator">**</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token keyword">return</span> idx1 <span class="token keyword">if</span> data<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span> <span class="token operator">>=</span> data<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span> <span class="token keyword">else</span> idx2<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    N<span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    data <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    init_log<span class="token punctuation">(</span><span class="token punctuation">)</span>    init_st<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    pos_max<span class="token punctuation">,</span> pos_1<span class="token punctuation">,</span> pos_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">-</span>M <span class="token comment" spellcheck="true"># 初始化查询范围 有点类似滑动窗口的意思</span>    <span class="token keyword">while</span> pos_1 <span class="token operator">&lt;</span> pos_2 <span class="token operator">&lt;</span> N<span class="token punctuation">:</span>        pos_max <span class="token operator">=</span> query<span class="token punctuation">(</span>data<span class="token punctuation">,</span> pos1<span class="token punctuation">,</span> pos2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 当前范围内的最大值位置</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>pos_max<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>        pos_1<span class="token punctuation">,</span> pos_2 <span class="token operator">=</span> pos_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> pos_2<span class="token operator">+</span><span class="token number">1</span>         <span class="token comment" spellcheck="true"># 左端点从最大值下一个开始，右端点+1 这里可以将左右端点看成一个区间 也可以将右端点到末尾看        # 成一个区间 右端点控制的是这一区间的长度</span>    <span class="token keyword">while</span> pos_2 <span class="token operator">!=</span> N<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 节目没有选慢 剩下的就必须全选</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>pos_2<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>        pos_2 <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一次的省赛模拟题感觉难度没有往年真题难，好像去年的模拟题也是这样一个难度的，但是还是学到了一些东西。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> write-up </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac环境下下载并播放blob视频</title>
      <link href="/posts/37450.html"/>
      <url>/posts/37450.html</url>
      
        <content type="html"><![CDATA[<p>今天想下载一个tx的视频，像往常一样，在chrome下打开，f12调出控制台，定位到视频所在位置，复制url，跳转到url..结果404 not found。仔细一看，这个视频url是这样的<code>blob:https://xxxx</code>。摸鱼20年，从来没见过这样的协议，但是它确实是在视频的<code>src</code>属性上，应该就是了。直接去掉blob前缀，依然无效。然后搜索了一下blob到底是个什么东西。</p><p>blob:https并不是一种协议，而是html5中blob对象在赋给video标签后生成的一串标记，blob对象包含的数据，浏览器内部会解析。直白一点的理解就是，网站将视频链接给隐藏了。对此，解决的办法就是直接在media中查看加载的视频文件。</p><p>本以为到这里就可以下载视频了，但是，打开media后，并没有任何内容，而页面上视频却正确的加载并播放了。考虑到长视频可能是使用了xhr，我又查看了一下xhr文件，果然有。但是却是一堆的文件。细看是ts文件，说明视频网站将视频资源分段了，又搜索了一下发现这是一种新的协议，m3u8。</p><p>m3u8是苹果公司推出的视频播放标准，是m3u的一种，只是编码格式采用的是UTF-8。m3u8准确来说是一种索引文件，使用m3u8文件实际上是通过它来解析对应的放在服务器上的视频网络地址，从而实现在线播放。使用m3u8格式文件主要因为可以实现多码率视频的适配，视频网站可以根据用户的网络带宽情况，自动为客户端匹配一个合适的码率文件进行播放，从而保证视频的流畅度。</p><p>因此，我们只要找到m3u8文件就可以了。一番搜索，我发现了m3u8文件，并且还对应着不同的清晰度。选择了一个m3u8文件下载后，打开发现里面确实都是ts文件的链接，应该就是将整个视频分段了。m3u8文件又应该如何下载。</p><p>再次Google，发现了两个工具：ffmpeg和vlc播放器。</p><p>ffmpeg是一个命令行工具，是视频处理最常用的开源软件，它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p><p>具体用法不多介绍，简单说一下：ffmpeg命令为5个参数 <code>ffmpeg {1} {2} -i {3} {4} {5}</code></p><p>1是全局参数， 2是输入文件参数， 3是输入文件， 4是输出参数，5是输出文件。ffmpeg可以直接下载m3u8文件的视频，只需要用以下命令<code>ffmpeg -i x.m3u8 x.ts</code>即可自动下载m3u8播放列表中的视频并拼接。但是实际使用中并未成功。另一个用法是用ffmpeg对ts格式进行转码：<code>ffmpeg -y -i x.ts -c:v libx264 -c:a copy -bsf:a aac_adtstoasc x.mp4</code>。使用此命令对下载的ts文件进行转码也出现错误。。。可能是我打开方式不太正确。</p><p>然后说一下vlc播放器。vlc播放器可以直接加载m3u8文件进行播放，如需下载，只需要在导入url时设置一下即可，这也是我目前成功的一种方法。</p><p>还有一种比较方便的方法可以直接下载m3u8视频。使用chrome插件，HDS-HLS-Video-Downloader，可直接捕获网页中的m3u8文件进行下载（虽然下载后的ts视频无法播放）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 摸鱼 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法整理</title>
      <link href="/posts/32294.html"/>
      <url>/posts/32294.html</url>
      
        <content type="html"><![CDATA[<h1 id="十大排序算法整理"><a href="#十大排序算法整理" class="headerlink" title="十大排序算法整理"></a>十大排序算法整理</h1><h2 id="总体分类"><a href="#总体分类" class="headerlink" title="总体分类"></a>总体分类</h2><p>首先解释一个概念，算法的稳定性：指序列中两相同的相邻元素在两趟排序的过程中相对位置是否发生改变，不改变为稳定的排序算法。</p><p>根据这个概念，我们可以对排序算法进行分类：</p><ol><li>稳定的排序算法：插入排序，冒泡排序， 归并排序， 基数排序，计数排序，桶排序</li><li>不稳定的排序算法；选择排序， 希尔排序， 快速排序， 堆排序</li></ol><p>再根据算法的时间复杂度，我们可以再对算法进行一次排序：</p><ol><li>$O(n^2)$:插入排序， 选择排序，冒泡排序</li><li>$O(nlog_2(n))$:快速排序，归并排序，堆排序</li><li>$O(n^ {1+§}), 0≤§≤1$:希尔排序</li><li>$O(n)$:基数排序，计数排序，桶排序</li></ol><p>下面对上述十种常用算法一一分析。</p><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>先从最简单的选择排序开始，这个算法的思想没有什么好说的，就是每一趟从未排序的序列中选出一个最大（小）值，然后放在序列末尾即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        max_idx <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>max_idx<span class="token punctuation">]</span><span class="token punctuation">:</span>                max_idx <span class="token operator">=</span> j        arr<span class="token punctuation">[</span>max_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>max_idx<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>插入排序的思路也很直观，将序列分为排序和未排序的部分，每次从未排序的部分中选择一个，插入到已排序的序列中的合适的位置即可。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># a[0]视为已排序序列</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># arr[i]是未排序序列中选取的那个 arr[j]是已排列的序列</span>                arr<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>j<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                arr<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>希尔排序是对插入排序的一种改进。插入排序对于完全有序的序列效率最高，对于完全无序的序列效率最低。希尔排序的思想就是先让序列部分有序，然后再进行插入排序，以此提高效率。为此，希尔排序中设计了增量的概念（个人理解就是分组大小），这个序列也不是随便选择的。希尔排序中使用的序列是${1, 4, 13, …, a_{n-1}*3+1}$，为什么不能使用如{1, 2, 4, 8}或其他的序列呢？因为希尔排序的复杂度是和增量序列的选择有关系的，经过数学证明，最好的一个序列为1，4， 13这样的序列。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    gap <span class="token operator">=</span> <span class="token number">1</span>     n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">while</span> gap <span class="token operator">&lt;</span> n<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 动态生成间隔序列</span>        gap <span class="token operator">=</span> gap<span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">while</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 间隔为1即为对整体进行插入排序</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>gap<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 将arr[0,gap,gap*2,..]分为一组 开始元素分别为0,1,gap-1</span>            tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 当前分组第i//gap个元素</span>            j <span class="token operator">=</span> i<span class="token operator">-</span>gap <span class="token comment" spellcheck="true"># 当前序列的逻辑索引 gap在逻辑上等于‘1’ 即 j=i-1 即j为arr[i]的上个元素 </span>            <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 升序排列 尽量将小元素向前排列</span>            <span class="token comment" spellcheck="true"># 插入排序 当tmp较小时，需要向前插入 这里是将arr[j]向后移动一位，为tmp插入做准备 </span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> gap <span class="token comment" spellcheck="true"># 此处的插入排序为倒序遍历</span>            arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp <span class="token comment" spellcheck="true"># 确定插入位置后 在此处插入</span>        gap <span class="token operator">=</span> gap<span class="token operator">//</span><span class="token number">3</span> <span class="token comment" spellcheck="true"># 缩小gap值，最终退化为插入排序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希尔排序中有一点不好理解的是，在排序过程中，每个单独的子序列并不是一次性排序完成的，而是按照原序列的顺序，一步一步的排序完成的。举个例子，若arr[i]属于子序列s1，当s1排序了一步后，总的序列将遍历到arr[i+1]（属于s2），此时则继续对s2进行插入排序。直到最后一个gap，主序列（外层循环）每推进1，就会完成一个子序列的插入排序。个人认为将每个子序列单独出来，完全排序完成后再处理下一个序列也是可行的，但是网络上见到的大多数希尔排序都是这样实现的，可能和性能有关？</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>冒泡排序也是一种非常常见的排序方法，每次比较两个元素，如果顺序错误就将其翻转。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>归并排序是使用分治思想的一个经典的算法。算法的主要思想就是将长序列化短，短序列化元，元序列（单个元素）自身看作有序，然后再进行合并即可。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> arr    m <span class="token operator">=</span> n<span class="token operator">//</span><span class="token number">2</span>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> merge<span class="token punctuation">(</span>merge_sort<span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> merge_sort<span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>    l<span class="token punctuation">,</span> L <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>left<span class="token punctuation">)</span>    r<span class="token punctuation">,</span> R <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>right<span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> L <span class="token operator">and</span> r <span class="token operator">&lt;</span> R<span class="token punctuation">:</span>        <span class="token keyword">if</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>            l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            r <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> l <span class="token operator">&lt;</span> L<span class="token punctuation">:</span>        res <span class="token operator">+=</span> left    <span class="token keyword">if</span> r <span class="token operator">&lt;</span> R<span class="token punctuation">:</span>        res <span class="token operator">+=</span> right    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>快速排序使用的也是一种分治的思想。正如名称，快速排序的实际表现比大多数复杂同为$O(nlog_2(n))$的算法更加高效。本质上看，快速排序是在冒泡排序的基础上的递归分治。算法的思想是首先从序列中选出一个元素作为“pivot”，将所有小于pivot的元素放在其左边，大于pivot的放在其右边。对于pivot左右两边，再递归的重复上述操作即可。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token operator">=</span>None<span class="token punctuation">,</span> right<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        m <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span>    i <span class="token operator">=</span> l    j <span class="token operator">=</span> r    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>        <span class="token keyword">while</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> x <span class="token operator">and</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">while</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x <span class="token operator">and</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span>    <span class="token keyword">return</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>堆排序是利用了堆这种数据结构来进行。这里是将序列构建为一个大（小）根堆，然后每次将堆顶的元素与</p><p>堆尾交换。然后将堆的大小减小1，重新构建堆。多次重复上述过程，即可完成排序。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">build_max_heap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        heapity<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>    left <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span>    right <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span>    largest <span class="token operator">=</span> i    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> arrLen <span class="token operator">and</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>        largest <span class="token operator">=</span> left    <span class="token keyword">if</span> right <span class="token operator">&lt;</span> arrLen <span class="token operator">and</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>        largest <span class="token operator">=</span> right    <span class="token keyword">if</span> largest <span class="token operator">!=</span> i<span class="token punctuation">:</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> arrLen    arrLen <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    build_max_heap<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        arrLen <span class="token operator">-=</span> <span class="token number">1</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>计数排序的原理是将序列中的数值都映射到额外的计数数组中去，当计数完成后，排序也完成了，只要按照所需的顺序复原立刻。计数排序要求序列中的值最大不能超过<code>max_value</code></p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    max_value <span class="token operator">=</span> <span class="token number">10000</span>    cnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>max_value    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        cnt<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>max_value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>            cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>桶排序是计数排序的一种更加通用的形式，他的原理是利用一个hash函数将序列中的元素映射到各个桶中去，然后再对桶中元素进行排序。当每个元素都均匀的分到每个桶中时，效率最高（极端情况退化为计数排序）。反之，所有元素都分配到同一个桶中的时候，效率最低。因此，桶排序的效率和hash函数有很大的关联。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bucket_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> bucketSize<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 默认桶的大小为5 越大越好</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> arr    max_value <span class="token operator">=</span> max<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>     min_value <span class="token operator">=</span> min<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    bucketCnt <span class="token operator">=</span> <span class="token punctuation">(</span>max_value<span class="token operator">-</span>min_value<span class="token punctuation">)</span><span class="token operator">//</span>bucketSize<span class="token operator">+</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 计算需要多少桶</span>    buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>bucketCnt<span class="token punctuation">)</span><span class="token punctuation">]</span>     <span class="token comment" spellcheck="true"># 此处即为hash函数的实现 f(arr[i])=(arr[i]-min_value)//bucketSize 可设计不同函数</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        buckets<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>min_value<span class="token punctuation">)</span><span class="token operator">//</span>bucketSize<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 对每个桶内的元素进行排列</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>bucketCnt<span class="token punctuation">)</span><span class="token punctuation">:</span>        insert_sort<span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 此处直接调用插入排序</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 将排序后的结果写到arr中作为结果</span>    <span class="token keyword">return</span> arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>基数排序是一种非比较型的整数排序算法，其原理是将整数按照位分割，然后对应每个位进行比较，比如说，同时比较所有数的个位，然后是十位，以此类推，这里同样运用了桶的概念。基数排序的桶是固定的，将0～9作为桶，每次都按照不同位将数字映射到这些桶中，以达到排序的目的。可以说基数排序是一种特殊的桶排序。</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">radix_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    digit <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 记录当前排序到第几位</span>    max_digit <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 记录最大位数</span>    max_value <span class="token operator">=</span> max<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token number">10</span><span class="token operator">**</span>max_digit <span class="token operator">&lt;</span> max_value<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 计算最大位数</span>        max_digit <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">while</span> digit <span class="token operator">&lt;</span> max_digit<span class="token punctuation">:</span>        tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 对每一位 进行一次桶排序</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">:</span>             t <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">10</span><span class="token operator">**</span>digit<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span> <span class="token comment" spellcheck="true"># 此处为该桶排序的hash函数 较为特殊</span>            tmp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        col <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> bucket <span class="token keyword">in</span> tmp<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 统计当前位的排序结果 基于此对下一位进行排序 达到整体排序的目的</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> bucket<span class="token punctuation">:</span>                col<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        arr <span class="token operator">=</span> col        digit <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python常用库之collections与itertools</title>
      <link href="/posts/8852.html"/>
      <url>/posts/8852.html</url>
      
        <content type="html"><![CDATA[<h1 id="python常用库之collections与itertools"><a href="#python常用库之collections与itertools" class="headerlink" title="python常用库之collections与itertools"></a>python常用库之collections与itertools</h1><p>最近看题解的时候发现好多问题可以直接使用内置库函数解决，及优雅又高效（开挂实锤）。下面依次来介绍这两个包的常见用法。</p><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p><code>collections</code>是Python内建的一个集合模块，提供了许多有用的集合类，这个模块实现了特定目标的容器，以提供Python标准内建容器 dict, list, set, 和 tuple的替代选择。相关连接：<a href="https://docs.python.org/zh-cn/3/library/collections.html" target="_blank" rel="noopener">官方文档</a>， <a href="https://www.kancloud.cn/smilesb101/python3_x/298822" target="_blank" rel="noopener">廖雪峰的python3教程</a>。</p><h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>这个是对tuple的扩展，<code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。用例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple<span class="token comment" spellcheck="true"># namedtuple('名称', [属性list]):</span><span class="token operator">>></span><span class="token operator">></span> Point <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Point'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>x<span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>y<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>namedtuple主要用于快速声明一个自定义tuple，避免创建class（完全可以用class代替）。其他具体用法见官方文档。</p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>在python中，数组对应着list。使用<code>list</code>存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为<code>list</code>是线性存储，数据量大的时候，插入和删除效率很低。<code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> qdeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Deque队列是由栈或者queue队列生成的（发音是 “deck”，”double-ended queue”的简称）。Deque 支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。虽然 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 对象也支持类似操作，不过这里优化了定长操作和 <code>pop(0)</code> 和 <code>insert(0, v)</code> 的开销。它们引起 O(n) 内存移动的操作，改变底层数据表达的大小和位置。<code>deque</code>除了实现<code>list</code>的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p><p>如果 <em>maxlen</em> 没有指定或者是 <code>None</code> ，deques 可以增长到任意长度。否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出。限定长度deque提供类似Unix filter <code>tail</code> 的功能。它们同样可以用与追踪最近的交换和其他数据池活动。</p><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>。defaultdict接受一个类型（其实是函数)作为输入，当访问的键不存在时，普通的dict会报错，而defaultdict就会自动创建该键并给出设定的类型的默认值。</p><p>eg1：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> s<span class="token punctuation">:</span>        d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 每个键在初次访问时都不存在，defaultdict会创建并默认给一个默认值（这里是[]),即d[k]为list</span><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>eg2：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token operator">>></span><span class="token operator">></span> dd <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token keyword">lambda</span><span class="token punctuation">:</span> <span class="token string">'N/A'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> dd<span class="token punctuation">[</span><span class="token string">'key1'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token operator">>></span><span class="token operator">></span> dd<span class="token punctuation">[</span><span class="token string">'key1'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># key1存在</span><span class="token string">'abc'</span><span class="token operator">>></span><span class="token operator">></span> dd<span class="token punctuation">[</span><span class="token string">'key2'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># key2不存在，返回默认值</span><span class="token string">'N/A'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里传入的参数就是一个函数，默认返回“N/A”。</p><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>使用<code>dict</code>时，<code>Key</code>是无序的。在对<code>dict</code>做迭代时，我们无法确定<code>Key</code>的顺序。如果要保持<code>Key</code>的顺序，可以用<code>OrderedDict</code>。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> OrderedDict<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d <span class="token comment" spellcheck="true"># dict的Key是无序的</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> od <span class="token operator">=</span> OrderedDict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> od <span class="token comment" spellcheck="true"># OrderedDict的Key是有序的</span>OrderedDict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，orderedDict中key的顺序是输入的顺序，并不是键值本身的顺序。另外有序字典的 <a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.OrderedDict.popitem" target="_blank" rel="noopener"><code>popitem()</code></a> 方法移除并返回一个 (key, value) 键值对。 如果 <em>last</em> 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对（默认为True)。</p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> Counter<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token string">'programming'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> cCounter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'g'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'p'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用处比较多，可以快速统计元素个数。输入参数是一个 <em>iterable</em> 被计数或其他的 <em>mapping</em> (or counter)：即可。</p><p>需要注意的是：设置一个计数为0不会从计数器中移去一个元素。使用 <code>del</code> 来删除它，Counter对象有一个字典接口，如果引用的键没有任何记录，就返回一个0，而不是弹出一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 。</p><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><p>Python的内建模块<code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p><h3 id="无限迭代器"><a href="#无限迭代器" class="headerlink" title="无限迭代器"></a>无限迭代器</h3><p>无限迭代器创建一个迭代器，它从 <em>start</em> 值开始，返回均匀间隔的值。常用于 <a href="https://docs.python.org/zh-cn/3/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 中的实参来生成连续的数据点。此外，还用于 <a href="https://docs.python.org/zh-cn/3/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a> 来添加序列号。<code>itertools.count(start=0, step=1)</code>, </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 常用库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列总结</title>
      <link href="/posts/33062.html"/>
      <url>/posts/33062.html</url>
      
        <content type="html"><![CDATA[<h1 id="全排列套路总结"><a href="#全排列套路总结" class="headerlink" title="全排列套路总结"></a>全排列套路总结</h1><p>做了2016年的蓝桥杯省赛之后，对于全排列的理解进一步加深，这里做一个小小的总结。</p><p>全排列主要有三种方式实现：</p><ol><li>库函数：next_permutations(C++)和<a href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.permutations" target="_blank" rel="noopener"><code>permutations</code></a> （python）</li><li>递归交换法</li><li>递归抽取法</li></ol><p>下面一一介绍。</p><h2 id="1-库函数-permutations"><a href="#1-库函数-permutations" class="headerlink" title="1. 库函数 permutations"></a>1. 库函数 permutations</h2><p>由于目前常用python，因此这里只介绍<a href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.permutations" target="_blank" rel="noopener"><code>permutations</code></a>。</p><p>这个函数是python内建库itertools的函数（最近发现了两个宝藏python库，可能会单独写一下），用法也比较简单。</p><pre class="line-numbers language-python"><code class="language-python">permutations<span class="token punctuation">(</span><span class="token string">'ABCD'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># AB AC AD BA BC BD CA CB CD DA DB DC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数是要排列的数据，第二个参数是选取的个数即：<code>permutations(x, y)</code> -&gt; $A_x^y$。如果省略y参数，默认为全排列（$A_n^n$）。</p><p>需要注意的是：</p><ol><li>排列依字典序发出。因此，如果 x 是已排序的，排列元组将有序地产出。</li><li>即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。即 <code>permutations('000', 3)</code> 输出为<code>[('0', '0', '0'), ('0', '0', '0'), ('0', '0', '0'), ('0', '0', '0'), ('0', '0', '0'), ('0', '0', '0')]</code>。</li></ol><p>既然谈到了permutation，那就顺便说一下同一个库中的combination。</p><pre class="line-numbers language-python"><code class="language-python">combinations<span class="token punctuation">(</span><span class="token string">'ABCD'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> AB AC AD BC BD CD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数用法同上，即<code>combinations(x, y)</code> -&gt; $C_x^y$。</p><p>注意事项：</p><ol><li>组合按照字典序返回。所以如果输入 x是有序的，生成的组合元组也是有序的。</li><li>即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。</li></ol><h2 id="2-递归交换法"><a href="#2-递归交换法" class="headerlink" title="2. 递归交换法"></a>2. 递归交换法</h2><p>这个方法其实就是dfs的回溯算法，直接在原序列进行交换和枚举。代码框架如下：</p><pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 原数据</span>n <span class="token operator">=</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 总长度</span>ans <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 符合条件的排列个数 即求解的答案</span><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 递归</span>    <span class="token keyword">global</span> ans     <span class="token keyword">if</span> k <span class="token operator">==</span> n<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 排列完全</span>        <span class="token keyword">if</span> check<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果满足条件则计数 check根据情况自定义</span>            ans <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 开始从k位置进行交换枚举</span>        swap<span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 可以在此提前剪枝，符合条件再继续递归。</span>        f<span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 递归</span>        swap<span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> K<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 回溯</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法生成的就是序列a的全排列，是将a中的每个元素当作不同的独立的元素来做的。如果数量稍微大一些可能会时间较长，可以在递归前提前剪枝。</p><h2 id="3-递归抓取法"><a href="#3-递归抓取法" class="headerlink" title="3. 递归抓取法"></a>3. 递归抓取法</h2><p>这个方法也是利用回溯的思想，不同的是需要用一个额外的path参数来记录当前抓取到的选择。这种抓取的思路就是按顺序从原序列中进行选择，全部选择完后即为答案。可以通过增加判断去除重复的情况，原理是确定一个固定的抓取顺序，这样所有的情况就是唯一的了。举例来说，就是如果<code>a[1]=0, a[2]=0</code>，则我先选择a[1]再选择a[2]和先选择a[2]再选择a[1]是同一种情况（数量更多出现的重复次数更多）。这时候，我们只需要规定一个固定的顺序，排除其他情况，就可以避免重复的出现。即规定必须先选择a[1]后才能选择a[2]，这样即使元素相同但是每种情况也都是唯一的了。</p><pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">,</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 原序列</span>n <span class="token operator">=</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span>vis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token comment" spellcheck="true"># 标记哪些元素被抓取过</span>ans <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># pos为当前枚举到的path位置 path记录当前的选择</span>    <span class="token keyword">global</span> ans    <span class="token comment" spellcheck="true"># 此部分同上</span>    <span class="token keyword">if</span> pos <span class="token operator">==</span> n<span class="token punctuation">:</span>        <span class="token keyword">if</span> check<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            ans <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 枚举抓取序列中的每个元素</span>        <span class="token comment" spellcheck="true">#用于排除重复情况 即将不同位置的相同元素示为同一种情况</span>        <span class="token comment" spellcheck="true"># 如果a[i]与a[i-1]相同并且a[i-1]还未被抓取，则这种情况会产生重复，直接跳过</span>        <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> <span class="token operator">not</span> vis<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>             <span class="token keyword">continue</span>        <span class="token comment" spellcheck="true"># 如果a[i] 还未被抓取，则可以进行枚举</span>        <span class="token keyword">if</span> <span class="token operator">not</span> vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>            path<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            f<span class="token punctuation">(</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>            vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 回溯</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><p>当然，大部分题目都不会直接是让你实现一个全排列这种问题，大部分都会在这个问题上加一层伪装，让你不是那么容易看出，具体例子可以看2016年蓝桥杯省赛，这里不再赘述。总之就是遇到多个元素直接需要满足某种关系，然后求一共有多少种方案这种题目，就可以用排列组合来解决。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小结 </tag>
            
            <tag> 全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>write-up-蓝桥杯2016省赛真题</title>
      <link href="/posts/14386.html"/>
      <url>/posts/14386.html</url>
      
        <content type="html"><![CDATA[<p>蓝桥杯2016省赛真题</p><p>这两天又做了2016年的蓝桥杯题目，感觉难度比2017年简单一些，是正常的蓝桥杯题目难度，难度逐年降低（反序😋）。话不多说，下面开始逐题分析。</p><p>ps: 最近被win折磨的不行，动不动explorer.exe cpu占用80%+，体验极差，已经下定决心装黑苹果或者Ubuntu，如果成功可能会简单的记录一下。</p><h1 id="真题分析"><a href="#真题分析" class="headerlink" title="真题分析"></a>真题分析</h1><h2 id="1-网友年龄"><a href="#1-网友年龄" class="headerlink" title="1. 网友年龄"></a>1. 网友年龄</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><pre><code>某君新认识一网友。当问及年龄时，他的网友说：“我的年龄是个2位数，我比儿子大27岁,如果把我的年龄的两位数字交换位置，刚好就是我儿子的年龄”请你计算：网友的年龄一共有多少种可能情况？提示：30岁就是其中一种可能哦.请填写表示可能情况的种数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>全是废话，就是枚举，没啥好说的</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">ans <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> i <span class="token operator">//</span> <span class="token number">10</span>    b <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">10</span>    s <span class="token operator">=</span> b<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>a    <span class="token keyword">if</span> i<span class="token operator">-</span>s <span class="token operator">==</span> <span class="token number">27</span><span class="token punctuation">:</span>        ans <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-生日蜡烛"><a href="#2-生日蜡烛" class="headerlink" title="2. 生日蜡烛"></a>2. 生日蜡烛</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><pre><code>某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。现在算起来，他一共吹熄了236根蜡烛。请问，他从多少岁开始过生日party的？请填写他开始过生日party的年龄数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</code></pre><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>等差数列求和+枚举</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n<span class="token operator">*</span>x<span class="token operator">+</span>n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">236</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-方格填数"><a href="#3-方格填数" class="headerlink" title="3. 方格填数"></a>3. 方格填数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><pre><code>方格填数如下的10个格子   +--+--+--+   |  |  |  |+--+--+--+--+|  |  |  |  |+--+--+--+--+|  |  |  |+--+--+--+填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻）一共有多少种可能的填数方案？请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</code></pre><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>本题其实就是一个全排列的问题。最开始做的时候最直观的想法就是构造一个二维数组，以每个点为起点开始填一遍（暴力枚举），但是最终做下来耗时较长。看了题解以后恍然大悟，这只不过是全排列的一种变形。我们只要对10个数进行全排列然后按序填入10个方格即可。然后根据方格位置固定关系check即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>ans <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>        abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>        abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>        abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>        abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>         abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span>        abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> ans    <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> check<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            ans <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 枚举</span>        swap<span class="token punctuation">(</span>k<span class="token punctuation">,</span> i<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 递归 选择下一位</span>        f<span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 回溯</span>        swap<span class="token punctuation">(</span>k<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    f<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>原题目说的乱七八糟，其实就是实现快速排序算法。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>经典排序算法，不再分析</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> a<span class="token punctuation">[</span>x<span class="token punctuation">]</span>     a<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>y<span class="token punctuation">]</span>    a<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> l    j <span class="token operator">=</span> r<span class="token operator">+</span><span class="token number">1</span>    x <span class="token operator">=</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> r <span class="token operator">and</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">while</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> x <span class="token operator">and</span> j <span class="token operator">>=</span> i<span class="token punctuation">:</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> i <span class="token operator">>=</span> j<span class="token punctuation">:</span>            <span class="token keyword">break</span>        swap<span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>    swap<span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> j<span class="token punctuation">)</span>    <span class="token keyword">return</span> j<span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>        q <span class="token operator">=</span> partition<span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> q<span class="token number">-1</span><span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>a<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-消除尾一"><a href="#5-消除尾一" class="headerlink" title="5. 消除尾一"></a>5. 消除尾一</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><pre><code>消除尾一下面的代码把一个整数的二进制表示的最右边的连续的1全部变成0如果最后一位是0，则原数字保持不变。如果采用代码中的测试数据，应该输出：00000000000000000000000001100111   0000000000000000000000000110000000000000000000000000000000001100   00000000000000000000000000001100请仔细阅读程序，填写划线部分缺少的代码。</code></pre><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>本题是代码填空题，主要是利用了按位运算的规律；核心为将原数+1后与原数做and操作即可。即               <code>x&amp;(x+1)</code>。代码不再给出。</p><h2 id="6-寒假作业"><a href="#6-寒假作业" class="headerlink" title="6. 寒假作业"></a>6. 寒假作业</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><pre><code>现在小学的数学题目也不是那么好玩的。看看这个寒假作业：  □ + □ = □  □ - □ = □  □ × □ = □  □ ÷ □ = □(如果显示不出来，可以参见【图7-1.jpg】)每个方块代表1~13中的某一个数字，但不能重复。比如： 6 + 7 = 13 9 - 8 = 1 3 * 4 = 12 10 / 2 = 5以及： 7 + 6 = 13 9 - 8 = 1 3 * 4 = 12 10 / 2 = 5就算两种解法。（加法，乘法交换律后算不同的方案）你一共找到了多少种方案？</code></pre><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>本题其实也是一道全排列的问题，只不过是把各个数位之间的关系改了一下。只需要根据题目更改一下check即可。但是由于问题的规模比较大$（12!）$,所以需要一些提前剪枝的技巧来提高效率。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">]</span>ans <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">and</span> \        a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">and</span> \        a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">and</span> \        a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">//</span>a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">and</span> \        a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">%</span>a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> a    t <span class="token operator">=</span> a<span class="token punctuation">[</span>x<span class="token punctuation">]</span>    a<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>y<span class="token punctuation">]</span>    a<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> ans<span class="token punctuation">,</span> a    <span class="token keyword">if</span> pos <span class="token operator">==</span> <span class="token number">13</span> <span class="token operator">and</span> check<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ans <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span>     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        swap<span class="token punctuation">(</span>i<span class="token punctuation">,</span> pos<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 此处为提前剪枝</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">and</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">5</span> <span class="token operator">and</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">!=</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dfs<span class="token punctuation">(</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        swap<span class="token punctuation">(</span>i<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-剪邮票"><a href="#7-剪邮票" class="headerlink" title="7. 剪邮票"></a>7. 剪邮票</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><pre><code>如【图1.jpg】, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）比如，【图2.jpg】，【图3.jpg】中，粉红（紫）色所示部分就是合格的剪取。请你计算，一共有多少种不同的剪取方法。请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</code></pre><p><img src="D:\blog\hexo-matery-modified\source\_posts\write-up-蓝桥杯2016省赛真题\image-20200326182835664.png" alt="image-20200326182835664" style="zoom:60%;"><img src="D:\blog\hexo-matery-modified\source\_posts\write-up-蓝桥杯2016省赛真题\image-20200326182758477.png" alt="image-20200326182758477" style="zoom:60%;"><img src="D:\blog\hexo-matery-modified\source\_posts\write-up-蓝桥杯2016省赛真题\image-20200326182758477.png" alt="image-20200326182758477" style="zoom:60%;"></p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>本题还是一道全排列题目的变种，只不过是带有重复的全排列。将12个格子放在一维数组中，选中为1，未选中为0；然后再利用dfs检查连通性即可。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">ans <span class="token operator">=</span> <span class="token number">0</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>vis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">12</span> <span class="token comment" spellcheck="true"># 用于全排列去重</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 检查连通性</span>    g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 该点被遍历</span>    <span class="token keyword">if</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> g<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        dfs<span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>    <span class="token keyword">if</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">and</span> g<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        dfs<span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>    <span class="token keyword">if</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        dfs<span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token number">3</span> <span class="token operator">and</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        dfs<span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 检查该答案合法性</span>    <span class="token comment" spellcheck="true"># 将全排列结果还原到数组中 便于check</span>    g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">4</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> path<span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">4</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>    cnt <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 连通子集个数</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 从存在点的地方开始搜索</span>                dfs<span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>                cnt <span class="token operator">+=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 搜索完成后个数加一</span>    <span class="token keyword">return</span> cnt <span class="token operator">==</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 如果只有一个连通集合，符合条件</span><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># k为a数组中的索引 path为记录已做的选择</span>    <span class="token keyword">global</span> ans    <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">12</span> <span class="token operator">and</span> check<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 出口条件</span>        ans <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 枚举 全排列</span>        <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> <span class="token operator">not</span> vis<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 去重</span>            <span class="token keyword">continue</span>          <span class="token keyword">if</span> <span class="token operator">not</span> vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 没有选取过 选取并遍历</span>            <span class="token comment" spellcheck="true"># 记录当前选择</span>            vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>             path<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            f<span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 继续选择</span>            vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span> <span class="token comment" spellcheck="true"># 回溯</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">12</span>    f<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-四平方和"><a href="#8-四平方和" class="headerlink" title="8. 四平方和"></a>8. 四平方和</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><pre><code>四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。比如：5 = 0^2 + 0^2 + 1^2 + 2^27 = 1^2 + 1^2 + 1^2 + 2^2（^符号表示乘方的意思）对于一个给定的正整数，可能存在多种平方和的表示法。要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。程序输入为一个正整数N (N&lt;5000000)要求输出4个非负整数，按从小到大排序，中间用空格分开例如，输入：5则程序应该输出：0 0 1 2再例如，输入：12则程序应该输出：0 2 2 2再例如，输入：773535则程序应该输出：1 1 267 838</code></pre><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>本题思路其实比较简单，暴力做法就是直接枚举。但是这样代码会超时，因此我们需要利用问题特性以及cache缓存来降低时间复杂度。在本问题中，设四个数字为<code>a, b, c, d</code>,总数量为<code>N</code> 他们满足如下关系：            $a^2&lt;= N/4, b^2&lt;=N/3, c^2&lt;=N/2, d^2&lt;=N$</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    N <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># cache 缓存数据 cache[c*c+d*d] = y: 平方和为c*c+d*d的c的最小值为y</span>    <span class="token comment" spellcheck="true"># 此处有一个小技巧 先计算c, d 便于构建缓存，同时降低复杂度到O(N^2)</span>    <span class="token keyword">for</span> c <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        d <span class="token operator">=</span> c        <span class="token keyword">while</span> d <span class="token operator">&lt;</span> N <span class="token operator">and</span> c<span class="token operator">*</span>c<span class="token operator">+</span>d<span class="token operator">*</span>d <span class="token operator">&lt;=</span> N<span class="token punctuation">:</span>            <span class="token keyword">if</span> c<span class="token operator">*</span>c<span class="token operator">+</span>d<span class="token operator">*</span>d <span class="token operator">not</span> <span class="token keyword">in</span> cache<span class="token punctuation">:</span>                cache<span class="token punctuation">[</span>c<span class="token operator">*</span>c<span class="token operator">+</span>d<span class="token operator">*</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> c            d <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">for</span> a <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        b <span class="token operator">=</span> a        <span class="token keyword">while</span> b <span class="token operator">&lt;</span> N<span class="token operator">//</span><span class="token number">2</span> <span class="token operator">and</span> a<span class="token operator">*</span>a<span class="token operator">+</span>b<span class="token operator">*</span>b<span class="token operator">&lt;=</span>N<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> N<span class="token operator">-</span>a<span class="token operator">*</span>a<span class="token operator">-</span>b<span class="token operator">*</span>b <span class="token keyword">in</span> cache<span class="token punctuation">:</span>                c <span class="token operator">=</span> cache<span class="token punctuation">[</span>N<span class="token operator">-</span>a<span class="token operator">*</span>a<span class="token operator">-</span>b<span class="token operator">*</span>b<span class="token punctuation">]</span>                d <span class="token operator">=</span> int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>N<span class="token operator">-</span>a<span class="token operator">*</span>a<span class="token operator">-</span>b<span class="token operator">*</span>b<span class="token operator">-</span>c<span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span>                <span class="token keyword">break</span>            b <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-密码脱落"><a href="#9-密码脱落" class="headerlink" title="9. 密码脱落"></a>9. 密码脱落</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><pre><code>X星球的考古学家发现了一批古代留下来的密码。这些密码是由A、B、C、D 四种植物的种子串成的序列。仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。你的任务是：给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。输入一行，表示现在看到的密码串（长度不大于1000）要求输出一个正整数，表示至少脱落了多少个种子。例如，输入：ABCBA则程序应该输出：0再例如，输入：ABECDCBABC则程序应该输出：3</code></pre><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>本题题目表述的比较花里胡哨，但是其实它只不过是利用了LCS来求解。但是这一层次比较难以想到，所以还是有一定难度的。如果用暴力法求解肯定只能获得一部分分数（超时）。</p><p>该问题是求镜像串，而镜像串的特点就是关于中心点对称，换句话说就是将原串反转后的得到的字符串与原串相同。现在的问题是原镜像串有一定的缺失，不满足镜像串的特性。我们可以这样处理：将缺失的串反转，然后和原串求其最长公共子序列，这样得到的串必定是原本不缺失的串的子序列。由于求的是最小数量，于是我们只需要将公共子序列根据给定的串补全即可；即用给定的缺失串的长度减去最长公共子序列的长度，即为答案。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><p>代码主要为LCS的dp解法，不再详细注释。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    re_s <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> re_s<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> n <span class="token operator">-</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-最大比例"><a href="#10-最大比例" class="headerlink" title="10. 最大比例"></a>10. 最大比例</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><pre><code>X星球的某个大奖赛设了M级奖励。每个级别的奖金是一个正整数。并且，相邻的两个级别间的比例是个固定值。也就是说：所有级别的奖金数构成了一个等比数列。比如：16,24,36,54 其等比值为：3/2。现在，我们随机调查了一些获奖者的奖金数。请你据此推算可能的最大的等比值。输入格式：第一行为数字N(n&lt;100)，表示接下的一行包含N个正整数。第二行N个正整数Xi(Xi&lt;1 000 000 000 000)，用空格分开。每个整数表示调查到的某人的奖金数额要求输出：一个形如A/B的分数，要求A、B互质。表示可能的最大比例系数。测试数据保证了输入格式正确，并且最大比例是存在的。例如，输入：31250 200 32程序应该输出：25/4再例如，输入：43125 32 32 200程序应该输出：5/2再例如，输入：3549755813888 524288 2程序应该输出：4/1</code></pre><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>本题就是一个数学问题，主要是等比数列的性质的应用。看了题解以后，发现思路其实并没有很复杂，但是代码量比较大，暂时未做python实现，代码实现以后待补充。</p><h1 id="2016省赛总结"><a href="#2016省赛总结" class="headerlink" title="2016省赛总结"></a>2016省赛总结</h1><p>2016年的省赛一共考察了三个全排列的题目，常见的全排列套路都进行了考察，从最基础的全排列，到全排列的优化到全排列的去除重复等都有考察，其余题目还是常规，前三题热身，代码填空消除尾一需要一定技巧，四平方和考察的是对大量枚举的优化，密码脱落可以说并不是考察LCS，而是考察对于问题的转化和平时的积累，最后一题则是蓝桥杯惯例的一道数学方面的问题了。整体来说难度适中，遇到一些很巧妙的题目时可以战略性跳过或者可以快速写出暴力解得到一部分分数。感觉全排列在这里出现的比较多了，考虑单独开一篇文章总结一下。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> write-up </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树+扫描线解矩形面积</title>
      <link href="/posts/54731.html"/>
      <url>/posts/54731.html</url>
      
        <content type="html"><![CDATA[<h1 id="线段树-扫描线解决矩形面积问题"><a href="#线段树-扫描线解决矩形面积问题" class="headerlink" title="线段树+扫描线解决矩形面积问题"></a>线段树+扫描线解决矩形面积问题</h1><p>蓝桥杯2017年省赛最后一题是求重叠矩形面积的题目，这类题目最常用的做法就是用线段树+扫描线来解决。又由于数据给的比较大，所以还需要对数据进行离散化处理。下面分别介绍线段树，扫面线的概念。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>线段树是常用来维护 <strong>区间信息</strong>的数据结构。</p><p>线段树可以在$O(logN)$的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。常用于解决矩形面积，矩形周长，区间和（最大最小值）等问题。</p><p>下面结合代码详细说明（以区间和为例）：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 树节点</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">,</span> left<span class="token operator">=</span>None<span class="token punctuation">,</span> right<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>start <span class="token operator">=</span> start <span class="token comment" spellcheck="true"># 区间开始点</span>        self<span class="token punctuation">.</span>end <span class="token operator">=</span> end <span class="token comment" spellcheck="true"># 区间结束点</span>        self<span class="token punctuation">.</span>sum <span class="token operator">=</span> val <span class="token comment" spellcheck="true"># 区间和 可以替换成最大值等等</span>        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left <span class="token comment" spellcheck="true"># 左子树</span>        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right <span class="token comment" spellcheck="true"># 右子树</span><span class="token keyword">def</span> <span class="token function">build_tree</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> vals<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 构建线段树</span>    <span class="token keyword">if</span> start <span class="token operator">==</span> end<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 叶子节点</span>        <span class="token keyword">return</span> SegmentTreeNode<span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span>     mid <span class="token operator">=</span> <span class="token punctuation">(</span>start<span class="token operator">+</span>end<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span> <span class="token comment" spellcheck="true"># 类似二分思想</span>    <span class="token comment" spellcheck="true"># 递归构建左右子树</span>    left <span class="token operator">=</span> build_tree<span class="token punctuation">(</span>start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> vals<span class="token punctuation">)</span>     right <span class="token operator">=</span> build_tree<span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> vals<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 返回根节点</span>    <span class="token keyword">return</span> SegmentTreeNode<span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> left<span class="token punctuation">.</span>sum<span class="token operator">+</span>right<span class="token punctuation">.</span>sum<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">update_tree</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 更新index节点的值并更新整棵树</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>start <span class="token operator">==</span> index <span class="token operator">==</span> root<span class="token punctuation">.</span>end<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 找到index节点</span>        root<span class="token punctuation">.</span>sum <span class="token operator">=</span> val <span class="token comment" spellcheck="true"># 更新节点值</span>        <span class="token keyword">return</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>start<span class="token operator">+</span>root<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span> <span class="token comment" spellcheck="true"># 二分</span>    <span class="token keyword">if</span> index <span class="token operator">></span> mid<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># index在右子树</span>        update_tree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 递归更新右子树</span>    <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 在左子树</span>        update_tree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 递归更新左子树</span>    root<span class="token punctuation">.</span>sum <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>sum<span class="token operator">+</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>sum <span class="token comment" spellcheck="true"># 更新当前节点</span><span class="token keyword">def</span> <span class="token function">query_sum</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 区间查询</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>start <span class="token operator">==</span> i <span class="token operator">and</span> root<span class="token punctuation">.</span>end <span class="token operator">==</span> j<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 查询区间等于当前节点区间</span>        <span class="token keyword">return</span> root<span class="token punctuation">.</span>sum    mid <span class="token operator">=</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>start<span class="token operator">+</span>root<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span> <span class="token comment" spellcheck="true"># 二分</span>    <span class="token keyword">if</span>  i<span class="token operator">></span>mid<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 查询区间左端点大于 mid 直接查询右子树</span>        <span class="token keyword">return</span> query_sum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>    <span class="token keyword">elif</span> j <span class="token operator">&lt;=</span> mid<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 同理</span>        <span class="token keyword">return</span> query_sum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 查询区间左端点在左子树，右端点在右子树 分别查询再合并</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> query_sum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> i<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token operator">+</span>query_sum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码不是很难理解，最主要是mid用的非常秒。mid参数也可以存下来避免每次计算</p><h3 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h3><p>扫描线其实并不是一个具体的数据结构，只是一种思想。利用扫描线，我们可以快速并且无重复的计算出矩形的面积。扫描线结构如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Line</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> height<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x1 <span class="token operator">=</span> x1 <span class="token comment" spellcheck="true"># 扫描线左端点</span>        self<span class="token punctuation">.</span>x2 <span class="token operator">=</span> x2 <span class="token comment" spellcheck="true"># 扫描线右端点</span>        self<span class="token punctuation">.</span>height <span class="token operator">=</span> height <span class="token comment" spellcheck="true"># 高度</span>        self<span class="token punctuation">.</span>f <span class="token operator">=</span> f <span class="token comment" spellcheck="true"># 1为入边 -1为出边</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题思路其实非常清晰，是扫描线+线段树的模板题。</p><p>首先将扫描线设定为平行于X轴的方向，将矩形的边都当作扫面线处理并储存起来。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面给出代码实现并结合代码解释具体细节。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> cmp_to_key<span class="token keyword">class</span> <span class="token class-name">Line</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 扫面线数据结构</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> h<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x1 <span class="token operator">=</span> x1 <span class="token comment" spellcheck="true"># 线段左端点</span>        self<span class="token punctuation">.</span>x2 <span class="token operator">=</span> x2 <span class="token comment" spellcheck="true"># 右端点</span>        self<span class="token punctuation">.</span>height <span class="token operator">=</span> h <span class="token comment" spellcheck="true"># 高度</span>        self<span class="token punctuation">.</span>f <span class="token operator">=</span> f <span class="token comment" spellcheck="true"># 入边=1  出边=-1</span><span class="token keyword">def</span> <span class="token function">line_cmp</span><span class="token punctuation">(</span>l1<span class="token punctuation">:</span>Line<span class="token punctuation">,</span> l2<span class="token punctuation">:</span>Line<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 扫描线排序</span>    <span class="token keyword">return</span> l1<span class="token punctuation">.</span>height <span class="token operator">-</span> l2<span class="token punctuation">.</span>height<span class="token keyword">class</span> <span class="token class-name">SegTree</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#线段树</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pl<span class="token punctuation">,</span> pr<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>pl <span class="token operator">=</span> pl <span class="token comment" spellcheck="true"># 区间左端点</span>        self<span class="token punctuation">.</span>pr <span class="token operator">=</span> pr <span class="token comment" spellcheck="true"># 区间右端点</span>        self<span class="token punctuation">.</span>cnt <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 覆盖次数计数</span>        self<span class="token punctuation">.</span>l <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 区间长度</span>        self<span class="token punctuation">.</span>lson <span class="token operator">=</span> None <span class="token comment" spellcheck="true"># 左子树</span>        self<span class="token punctuation">.</span>rson <span class="token operator">=</span> None <span class="token comment" spellcheck="true"># 右子树</span>N <span class="token operator">=</span> <span class="token number">10000</span>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>N<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 存储N个矩形的2N个顶点</span>lines <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 扫描线数组</span><span class="token keyword">def</span> <span class="token function">build_tree</span><span class="token punctuation">(</span>pl <span class="token punctuation">,</span>pr<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 构建扫描树（空）</span>    t <span class="token operator">=</span> SegTree<span class="token punctuation">(</span>pl<span class="token punctuation">,</span> pr<span class="token punctuation">)</span>    <span class="token keyword">if</span> pl <span class="token operator">==</span> pr<span class="token punctuation">:</span>        <span class="token keyword">return</span> t    mid <span class="token operator">=</span> <span class="token punctuation">(</span>pl<span class="token operator">+</span>pr<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>    t<span class="token punctuation">.</span>lson <span class="token operator">=</span> build_tree<span class="token punctuation">(</span>pl<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>    t<span class="token punctuation">.</span>rson <span class="token operator">=</span> build_tree<span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> pr<span class="token punctuation">)</span>    <span class="token keyword">return</span> t<span class="token keyword">def</span> <span class="token function">update_length</span><span class="token punctuation">(</span>pTree<span class="token punctuation">:</span> SegTree<span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tr<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 更新当前节点的长度</span>    <span class="token keyword">if</span> pTree<span class="token punctuation">.</span>cnt<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果被覆盖（入边）</span>        pTree<span class="token punctuation">.</span>l <span class="token operator">=</span> X<span class="token punctuation">[</span>tr<span class="token punctuation">]</span><span class="token operator">-</span>X<span class="token punctuation">[</span>tl<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 长度为该扫描线的长度</span>    <span class="token keyword">elif</span> tl <span class="token operator">==</span> tr<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果为出边，而且区间左右端点相同</span>        pTree<span class="token punctuation">.</span>l <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 长度为0</span>    <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 为出边而且区间左右端点不同</span>        pTree<span class="token punctuation">.</span>l <span class="token operator">=</span> pTree<span class="token punctuation">.</span>lson<span class="token punctuation">.</span>l <span class="token operator">+</span> pTree<span class="token punctuation">.</span>rson<span class="token punctuation">.</span>l <span class="token comment" spellcheck="true"># l为其左右子树的长度之和</span><span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>tree<span class="token punctuation">:</span> SegTree<span class="token punctuation">,</span> pl<span class="token punctuation">,</span> pr<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 更新区间树,pl,pr都是X的索引,value是要更新的值</span>    <span class="token keyword">if</span> <span class="token operator">not</span> tree<span class="token punctuation">:</span>        <span class="token keyword">return</span>    tl <span class="token operator">=</span> tree<span class="token punctuation">.</span>pl <span class="token comment" spellcheck="true"># 当前树节点的左端点</span>    tr <span class="token operator">=</span> tree<span class="token punctuation">.</span>pr <span class="token comment" spellcheck="true"># 右端点</span>    <span class="token keyword">if</span> pl <span class="token operator">&lt;=</span> tl <span class="token operator">and</span> pr <span class="token operator">>=</span> tr<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 要更新的区间（pl，pr）整好在该节点的范围内 即属于该节点</span>        tree<span class="token punctuation">.</span>cnt <span class="token operator">+=</span> value <span class="token comment" spellcheck="true"># 更新cnt value是f即出入边 与cnt相加为覆盖次数</span>        update_length<span class="token punctuation">(</span>tree<span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 更新区间长度</span>        <span class="token keyword">return</span>    m <span class="token operator">=</span> <span class="token punctuation">(</span>tl <span class="token operator">+</span> tr<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>     <span class="token keyword">if</span> pl <span class="token operator">&lt;=</span> m<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 更新其左子树</span>        update<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>lson<span class="token punctuation">,</span> pl<span class="token punctuation">,</span> pr<span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token keyword">if</span> pr <span class="token operator">></span> m<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 更新其右子树</span>        update<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>rson<span class="token punctuation">,</span> pl<span class="token punctuation">,</span> pr<span class="token punctuation">,</span> value<span class="token punctuation">)</span>    update_length<span class="token punctuation">(</span>tree<span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 更新长度</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    index <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 扫描线个数计数</span>    ans <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 最终答案</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>        x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2 <span class="token operator">=</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 每读入一个矩形 添加两条扫描线</span>        X<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> x1        lines<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Line<span class="token punctuation">(</span>min<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">,</span> y1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        index <span class="token operator">+=</span> <span class="token number">1</span>        X<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> x2        lines<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Line<span class="token punctuation">(</span>min<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">,</span> y2<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        index <span class="token operator">+=</span> <span class="token number">1</span>    X <span class="token operator">=</span> X<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span>    X <span class="token operator">=</span> list<span class="token punctuation">(</span>set<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 端点去重</span>    X<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 排序</span>    lines<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span>cmp_to_key<span class="token punctuation">(</span>line_cmp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 扫描线按照高度排序</span>    <span class="token comment" spellcheck="true"># x_end = len(set(X))</span>    x_end <span class="token operator">=</span> len<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 去重后的总数量</span>    root <span class="token operator">=</span> build_tree<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> x_end<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 构建扫描树</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>index<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        pl <span class="token operator">=</span> X<span class="token punctuation">.</span>index<span class="token punctuation">(</span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 从X中找到line[i]的左端点的真正索引（X经过排序被打乱）</span>        pr <span class="token operator">=</span> X<span class="token punctuation">.</span>index<span class="token punctuation">(</span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 从X中找到line[i]的右端点</span>        update<span class="token punctuation">(</span>root<span class="token punctuation">,</span> pl<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> pr<span class="token punctuation">,</span> lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>f<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 更新区间树</span>        <span class="token comment" spellcheck="true"># 用当前扫描线长度*两扫描线高度之差记为当前区域长方形面积</span>        ans <span class="token operator">+=</span> root<span class="token punctuation">.</span>l<span class="token operator">*</span><span class="token punctuation">(</span>lines<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token operator">-</span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 扫描线 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>write-up 蓝桥杯2017省赛真题</title>
      <link href="/posts/1767.html"/>
      <url>/posts/1767.html</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯2017省赛真题"><a href="#蓝桥杯2017省赛真题" class="headerlink" title="蓝桥杯2017省赛真题"></a>蓝桥杯2017省赛真题</h1><p>最近做了一下蓝桥杯2017年省赛的真题，越发让我感到自己水平低下🙃，看来上次三等奖名副其实。差不多一半的题目没有很好的思路，甚至有些题在看题解时又双触及到了知识盲区。对比前几年的情况，17年蓝桥杯感觉略有难度（暴力杯没错了），难度逐年上升。下面逐题分析。</p><h1 id="真题分析"><a href="#真题分析" class="headerlink" title="真题分析"></a>真题分析</h1><h2 id="1-迷宫"><a href="#1-迷宫" class="headerlink" title="1. 迷宫"></a>1. 迷宫</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><pre><code>X星球的一处迷宫游乐场建在某个小山坡上。它是由10x10相互连通的小房间组成的。房间的地板上写着一个很大的字母。我们假设玩家是面朝上坡的方向站立，则：L表示走到左边的房间，R表示走到右边的房间，U表示走到上坡方向的房间，D表示走到下坡方向的房间。X星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！开始的时候，直升机把100名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。迷宫地图如下：UDDLUULRULUURLLLRRRURRUURLDLRDRUDDDDUUUUURUDLLRRUUDURLRLDLRLULLURLLRDURDLULLRDDDUUDDUDUDLLULRDLUURRR请你计算一下，最后，有多少玩家会走出迷宫?而不是在里边兜圈子。请提交该整数，表示走出迷宫的玩家数目，不要填写任何多余的内容。如果你还没明白游戏规则，可以参看一个简化的4x4迷宫的解说图：</code></pre><p><img src="D:%5Cblog%5Chexo-matery-modified%5Csource_posts%5Cwrite-up-%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%5Cp1-1.png" alt="p1-1"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一个经典的dfs问题，没有什么太多的技巧，只需要对每个节点进行dfs搜索即可,同时用一个vis数组来记录遍历过的地方，避免重复。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">vis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>maze <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'UDDLUULRUL'</span><span class="token punctuation">,</span>        <span class="token string">'UURLLLRRRU'</span><span class="token punctuation">,</span>        <span class="token string">'RRUURLDLRD'</span><span class="token punctuation">,</span>        <span class="token string">'RUDDDDUUUU'</span><span class="token punctuation">,</span>        <span class="token string">'URUDLLRRUU'</span><span class="token punctuation">,</span>        <span class="token string">'DURLRLDLRL'</span><span class="token punctuation">,</span>        <span class="token string">'ULLURLLRDU'</span><span class="token punctuation">,</span>        <span class="token string">'RDLULLRDDD'</span><span class="token punctuation">,</span>        <span class="token string">'UUDDUDUDLL'</span><span class="token punctuation">,</span>        <span class="token string">'ULRDLUURRR'</span><span class="token punctuation">]</span>ans <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span>int<span class="token punctuation">,</span> y<span class="token punctuation">:</span>int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">9</span> <span class="token operator">or</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">or</span> y <span class="token operator">></span> <span class="token number">9</span> <span class="token operator">or</span> y <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">if</span> vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>    c <span class="token operator">=</span> maze<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span>    <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'U'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>    <span class="token keyword">elif</span> c <span class="token operator">==</span> <span class="token string">'D'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>    <span class="token keyword">elif</span> c <span class="token operator">==</span> <span class="token string">'L'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> c <span class="token operator">==</span> <span class="token string">'R'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> vis    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            vis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">10</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>                ans <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>一拿到这道题，我的第一想法就是dfs，也是一个很常见的dfs问题。但是为了降低时间复杂度，我突然想到了利用动态规划来解决这个问题（💩最近做多了有点上头），最后一顿分析+瞎写代码成功的未解决问题。仔细一想其实根本不是动态规划问题，并没有出现明显的递推关系。</p><h2 id="2-跳蚱蜢"><a href="#2-跳蚱蜢" class="headerlink" title="2. 跳蚱蜢"></a>2. 跳蚱蜢</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><pre><code>有9只盘子，排成1个圆圈。其中8只盘子内装着8只蚱蜢，有一个是空盘。我们把这些蚱蜢顺时针编号为 1~8每只蚱蜢都可以跳到相邻的空盘中，也可以再用点力，越过一个相邻的蚱蜢跳到空盘中。请你计算一下，如果要使得蚱蜢们的队形改为按照逆时针排列，并且保持空盘的位置不变（也就是1-8换位，2-7换位,...），至少要经过多少次跳跃？注意：要求提交的是一个整数，请不要填写任何多余内容或说明文字。</code></pre><p><img src="D:%5Cblog%5Chexo-matery-modified%5Csource_posts%5Cwrite-up-%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%5Cp2-1.png" alt="p2-1"></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题是一个bfs的问题，乍一看，这个问题好像dfs也可以解决，但是由于求的是最小的跳跃次数，所以最终来说还是要用bfs来解决。将空白处记为0号点，我们每次都可以选择其相邻的左右各两位。如图，也就是0号可以和1， 2， 7， 8号互换位置。我们的初始状态记为“012345678”，目标状态记为“087654321”，只要有一个情况达到了目标状态，返回当前步数即可。</p><p>另外，因为题目给出的是一个圆环，也就意味着0和8是相邻的，这里只要用取余的技巧处理一下即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">start <span class="token operator">=</span> <span class="token string">'012345678'</span>target <span class="token operator">=</span> <span class="token string">'087654321'</span><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> status<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>status <span class="token operator">=</span> status <span class="token comment" spellcheck="true"># 当前节点状态</span>        self<span class="token punctuation">.</span>pos <span class="token operator">=</span> pos <span class="token comment" spellcheck="true"># 当前0所在的位置</span>        self<span class="token punctuation">.</span>depth <span class="token operator">=</span> depth <span class="token comment" spellcheck="true"># 当前节点深度，即步数</span>q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 队列</span>vis <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 利用set判重</span><span class="token keyword">def</span> <span class="token function">addNei</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> depth<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> new_pos<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 添加子节点</span>    <span class="token comment" spellcheck="true"># 交换status的pos位置和new_pos位置。 由于python中str类型为不可变类型，故处理略微麻烦</span>    p0 <span class="token operator">=</span> status<span class="token punctuation">[</span>pos<span class="token punctuation">]</span>    np <span class="token operator">=</span> status<span class="token punctuation">[</span>new_pos<span class="token punctuation">]</span>    new_status <span class="token operator">=</span> status<span class="token punctuation">[</span><span class="token punctuation">:</span>pos<span class="token punctuation">]</span><span class="token operator">+</span>np<span class="token operator">+</span>status<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    new_status <span class="token operator">=</span> new_status<span class="token punctuation">[</span><span class="token punctuation">:</span>new_pos<span class="token punctuation">]</span><span class="token operator">+</span>p0<span class="token operator">+</span>new_status<span class="token punctuation">[</span>new_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> new_status <span class="token operator">not</span> <span class="token keyword">in</span> vis<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 若这个状态未出现过 判重</span>        vis<span class="token punctuation">.</span>add<span class="token punctuation">(</span>new_status<span class="token punctuation">)</span>         q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Node<span class="token punctuation">(</span>new_status<span class="token punctuation">,</span> new_pos<span class="token punctuation">,</span> level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#队列中添加该节点</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Node<span class="token punctuation">(</span>start<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 初始节点</span>    <span class="token keyword">while</span> q<span class="token punctuation">:</span>        node <span class="token operator">=</span> q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>         status <span class="token operator">=</span> node<span class="token punctuation">.</span>status        pos <span class="token operator">=</span> node<span class="token punctuation">.</span>pos        depth <span class="token operator">=</span> node<span class="token punctuation">.</span>depth        <span class="token keyword">if</span> status <span class="token operator">==</span> target<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 到达目标状态，输出即可</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>depth<span class="token punctuation">)</span>            <span class="token keyword">break</span>        vis<span class="token punctuation">.</span>add<span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 将这个状态添加到vis中去重</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 遍历四种情况</span>            <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            new_pos <span class="token operator">=</span> <span class="token punctuation">(</span>pos <span class="token operator">+</span> i<span class="token operator">+</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">9</span> <span class="token comment" spellcheck="true"># 利用取余技巧处理圆环 即循环数组</span>            addNei<span class="token punctuation">(</span>status<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> pos<span class="token punctuation">,</span> new_pos<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 将改节点添加至搜索队列中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这道题本事其实并不太困难，主要是要及时利用“最少步数”看出是用bfs进行搜索即可，另外代码中有几处小细节的处理需要注意即可。</p><h2 id="3-魔方状态"><a href="#3-魔方状态" class="headerlink" title="3. 魔方状态"></a>3. 魔方状态</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><pre><code>二阶魔方就是只有2层的魔方，只由8个小块组成。小明很淘气，他只喜欢3种颜色，所有把家里的二阶魔方重新涂了颜色，如下：前面：橙色右面：绿色上面：黄色左面：绿色下面：橙色后面：黄色请你计算一下，这样的魔方被打乱后，一共有多少种不同的状态。如果两个状态经过魔方的整体旋转后，各个面的颜色都一致，则认为是同一状态。请提交表示状态数的整数，不要填写任何多余内容或说明文字。</code></pre><p><img src="D:%5Cblog%5Chexo-matery-modified%5Csource_posts%5Cwrite-up-%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%5Cp3-1.png" alt="p3-1"></p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>本题的描述很简单，就是求魔方有多少种状态，一种很浓烈的dfs的味道。但是仔细一想其实问题其实还挺复杂。</p><p>魔方的变化方式总共只有三种方式，每种选择方式都对应着4个小面的变化：</p><ol><li>前面旋转</li><li>上面旋转</li><li>侧面旋转</li></ol><h2 id="4-方块分割"><a href="#4-方块分割" class="headerlink" title="4. 方块分割"></a>4. 方块分割</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><pre><code>6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。如图4-1,4-2,4-3：就是可行的分割法。试计算：包括这3种分法在内，一共有多少种不同的分割方法。注意：旋转对称的属于同一种分割法。请提交该整数，不要填写任何多余的内容或说明文字。</code></pre><p><img src="D:\blog\hexo-matery-modified\source\_posts\write-up-蓝桥杯2017省赛真题\p4-1-1584605627591.png" alt="p4-1" style="zoom:67%;">![p4-2](D:\OneDrive\蓝桥\C  A\2017CA\2017_C_A\p4-2.png)<img src="D:\blog\hexo-matery-modified\source\_posts\write-up-蓝桥杯2017省赛真题\p4-1-1584605627591.png" alt="p4-1" style="zoom:67%;">![p4-2](D:\OneDrive\蓝桥\C  A\2017CA\2017_C_A\p4-2.png)![p4-3](D:\OneDrive\蓝桥\C  A\2017CA\2017_C_A\p4-3.png)<img src="D:\blog\hexo-matery-modified\source\_posts\write-up-蓝桥杯2017省赛真题\p4-1-1584605627591.png" alt="p4-1" style="zoom:67%;">![p4-2](D:\OneDrive\蓝桥\C  A\2017CA\2017_C_A\p4-2.png)![p4-3](D:\OneDrive\蓝桥\C  A\2017CA\2017_C_A\p4-3.png)</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>本题其实还是一道dfs的题目，只不过需要一定的技巧来构造。</p><p>仔细观察图片的分割线，我们可以发现所有分割线都要经过图片的中心，即分割线都是关于图片中心对称的。因此，我们只要构造一条经过图片中心的分割线，就一定是对称的，符合题意的。因此，本题的dfs出发点就是这个图的中心点。只要我们从中心点出发，那么就一定会经过中心点，这样相当于极大的缩小了解空间。然后，根据题意排除重复情况即可（最终情况/4即可）。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">dire <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>vis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">7</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 用于判重</span>ans <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> ans<span class="token punctuation">,</span> vis    <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> x <span class="token operator">==</span> <span class="token number">6</span> <span class="token operator">or</span> y <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> y <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 超出边界 即分割完成</span>        ans <span class="token operator">+=</span> <span class="token number">1</span>         <span class="token keyword">return</span>    <span class="token keyword">if</span> vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 重复情况</span>        <span class="token keyword">return</span>    <span class="token comment" spellcheck="true"># 将 (x, y)和其中心对称的点标记</span>    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>     vis<span class="token punctuation">[</span><span class="token number">6</span><span class="token operator">-</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token operator">-</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token comment" spellcheck="true"># 遍历四个方向</span>    <span class="token keyword">for</span> d <span class="token keyword">in</span> dire<span class="token punctuation">:</span>        dfs<span class="token punctuation">(</span>x<span class="token operator">+</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">+</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 完成当前节点的遍历后，需要回溯，避免对其他情况的影响</span>    <span class="token comment" spellcheck="true"># 由于每一次调用结束都会回溯一次，相当于递归回溯，即消除了由此节点引起的全部影响</span>    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>    vis<span class="token punctuation">[</span><span class="token number">6</span><span class="token operator">-</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token operator">-</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    dfs<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 每旋转90°是一个对称的情况，所以要除以4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-字母组串"><a href="#5-字母组串" class="headerlink" title="5. 字母组串"></a>5. 字母组串</h2><p>本题是一个代码填空题，较为简单，跳过</p><h2 id="6-最大公共子串"><a href="#6-最大公共子串" class="headerlink" title="6.最大公共子串"></a>6.最大公共子串</h2><p>同上，dp的模板代码填空题</p><h2 id="7-正则问题"><a href="#7-正则问题" class="headerlink" title="7.正则问题"></a>7.正则问题</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><pre><code>考虑一种简单的正则表达式： 只由 x ( ) | 组成的正则表达式。 小明想求出这个正则表达式能接受的最长字符串的长度。例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6。一个由x()|组成的正则表达式。输入长度不超过100，保证合法。这个正则表达式能接受的最长字符串的长度。输入：((xx|xxx)x|(x|xx))xx  1输出：6 </code></pre><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>本题也是一道dfs的题目。仔细观察分析一下，题目的输入只有“（”， “）”， “x”， “|”这四种。总体上看，题目的答案等于<code>括号外直接的‘x’数量+括号内的数量</code>，遇到‘|”取两边的最大值即可。如何得到括号内的数量？只需要再次重复上述过程即可，很明显这是一个递归的过程。我们只要用一个全局的指针来遍历字符串，根据不同的符号来进行不同操作即可。</p><ol><li><p>“（”</p><p>当我们遇到“（”时，代表我们需要递归的处理括号内的情况；抽象的来说这里就相当于得到括号内的值。</p></li><li><p>“）”</p><p>这种情况意味着当前“（”情况的结束，我们只需要返回当前括号内的值即可。</p></li><li><p>“x”</p><p>这是最直接的情况，只需要计数并指针移动即可。</p></li><li><p>”|“</p><p>遇到”|“时，我们需要对”|“前的情况（”（“内）进行一次结算；为与”|“后的数量比较大小做准备；</p></li></ol><p>下面看具体代码。</p><p>代码</p><pre class="line-numbers language-python"><code class="language-python">s <span class="token operator">=</span> <span class="token string">''</span>　<span class="token comment" spellcheck="true"># 待处理字符串</span>pos <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 全局指针</span>l <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 总长度</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 递归模拟</span>    <span class="token keyword">global</span> pos    tmp <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 临时保存每一次结果，每个“|”重置一次， 便于比较两部分取最优</span>    ans <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 最终结果</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 未到终点</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"x"</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 直接统计即可</span>            pos <span class="token operator">+=</span> <span class="token number">1</span>            tmp <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"("</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 需要递归处理 抽象为得到这个括号</span>            pos <span class="token operator">+=</span> <span class="token number">1</span>            tmp <span class="token operator">+=</span> dfs<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 暂存结果</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">")"</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 结束当前括号的情况 返回当前括号的最终结果</span>            pos <span class="token operator">+=</span> <span class="token number">1</span>            ans <span class="token operator">=</span> max<span class="token punctuation">(</span>ans<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 选取最优解</span>            <span class="token keyword">return</span> ans        <span class="token keyword">if</span> s<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"|"</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 暂存当前结果 需要选取最优解 </span>            pos <span class="token operator">+=</span> <span class="token number">1</span>            ans <span class="token operator">=</span> max<span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> ans<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 取最优</span>            tmp <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 重置</span>    <span class="token keyword">return</span> max<span class="token punctuation">(</span>ans<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 如果没有遇到“）”， 直接返回结果</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>     s <span class="token operator">=</span> <span class="token string">'((xx|xxx)x|(x|xx))xx'</span>    l <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>dfs<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-包子凑数"><a href="#8-包子凑数" class="headerlink" title="8. 包子凑数"></a>8. 包子凑数</h2><pre><code>小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。小明想知道一共有多少种数目是包子大叔凑不出来的。输入----第一行包含一个整数N。(1 &lt;= N &lt;= 100)以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100) 输出----一个整数代表答案。如果凑不出的数目有无限多个，输出INF。例如，输入：2  4  5  程序应该输出：6 再例如，输入：2  4  6   程序应该输出：INF样例解释：对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。  对于样例2，所有奇数都凑不出来，所以有无限多个。 </code></pre><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>本题可以说是一道数学问题，如果没有相关的知识可能会很难做（我）。但是如果了解了相关知识，其实代码并不复杂。下面补充一下相关数学知识：</p><h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><p>已知整数a、b，扩展欧几里得算法可以在求得a、b的<a href="https://zh.wikipedia.org/wiki/最大公约数" target="_blank" rel="noopener">最大公约数</a>的同时，能找到整数x、y（其中一个很可能是负数），使它们满足<a href="https://zh.wikipedia.org/wiki/貝祖等式" target="_blank" rel="noopener">贝祖等式</a>:</p><p>$ax+by=gcd(a,b)$ </p><p>由定理可知，如果$gcd(a, b)=1$,那么就可以凑出任意包子数。即如果a,b互质的话就可以凑出任意的包子数了。到这里，这个问题就基本解决了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">101</span> <span class="token comment" spellcheck="true"># 存储蒸笼数据</span>f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">10000</span> <span class="token comment" spellcheck="true"># 类dp数组</span><span class="token keyword">def</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># gcd python中其实有内置函数</span>    <span class="token keyword">if</span> <span class="token operator">not</span> b<span class="token punctuation">:</span>        <span class="token keyword">return</span> a    <span class="token keyword">return</span> gcd<span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">%</span>b<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true"># base case 0当然可以凑出</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 读入蒸笼</span>        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果是第一个 公约数是自己</span>            g <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            g <span class="token operator">=</span> gcd<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># g是公约数</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 每读入一个新的蒸笼，扫描一遍 更新可以凑出的数量</span>                <span class="token keyword">if</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">and</span> j<span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果f[j]可以凑出，那么f[j+a[i]]一定可以凑出</span>                    f<span class="token punctuation">[</span>j<span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">if</span> g <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"INF\n"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                ans <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-分巧克力"><a href="#9-分巧克力" class="headerlink" title="9.分巧克力"></a>9.分巧克力</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><pre><code> 儿童节那天有 K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。小明一共有 N 块巧克力，其中第 i 块是 Hi x Wi 的方格组成的长方形。为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。切出的巧克力需要满足：1. 形状是正方形，边长是整数  2. 大小相同  例如一块 6x5 的巧克力可以切出 6 块 2x2 的巧克力或者 2 块 3x3 的巧克力。当然小朋友们都希望得到的巧克力尽可能大，你能帮小 Hi 计算出最大的边长是多少么？输入第一行包含两个整数 N 和 K。(1 &lt;= N, K &lt;= 100000)  以下 N 行每行包含两个整数 Hi 和 Wi。(1 &lt;= Hi, Wi &lt;= 100000)输入保证每位小朋友至少能获得一块 1x1 的巧克力。   输出输出切出的正方形巧克力最大可能的边长。样例输入：2 10  6 5  5 6  样例输出：2</code></pre><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>这道题直接的思路其实很简单，就直接暴力搜索就可以了。由于求最大边长，我们只要从高到低的顺序搜索即可。但是这样做了以后超时了。仔细一想，我们只需要在搜索巧克力大小时候使用二分法的技巧来处理即可大大降低时间复杂度。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">100000</span>    w <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">100000</span>    tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    n<span class="token punctuation">,</span> k <span class="token operator">=</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>        h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    r <span class="token operator">=</span> <span class="token number">100001</span>    l <span class="token operator">=</span> <span class="token number">1</span>    ans <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> r<span class="token operator">>=</span>l<span class="token punctuation">:</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>r<span class="token operator">+</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>        cnt <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt <span class="token operator">+=</span> <span class="token punctuation">(</span>h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">//</span>mid<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">//</span>mid<span class="token punctuation">)</span>        <span class="token keyword">if</span> cnt <span class="token operator">></span> k<span class="token punctuation">:</span>            l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            ans <span class="token operator">=</span> mid        <span class="token keyword">else</span><span class="token punctuation">:</span>            r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-油漆面积"><a href="#10-油漆面积" class="headerlink" title="10.油漆面积"></a>10.油漆面积</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><pre><code>X星球的一批考古机器人正在一片废墟上考古。 该区域的地面坚硬如石、平整如镜。 管理人员为方便，建立了标准的直角坐标系。每个机器人都各有特长、身怀绝技。它们感兴趣的内容也不相同。 经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。矩形的表示格式为(x1,y1,x2,y2)，代表矩形的两个对角点坐标。为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆。 小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。 注意，各个矩形间可能重叠。本题的输入为若干矩形，要求输出其覆盖的总面积。输入格式：第一行，一个整数n，表示有多少个矩形(1&lt;=n&lt;10000) 接下来的n行，每行有4个整数x1 y1 x2 y2，空格分开，表示矩形的两个对角顶点坐标。 (0&lt;= x1,y1,x2,y2 &lt;=10000)输出格式：一行一个整数，表示矩形覆盖的总面积。输入：31 5 10 103 1 20 202 7 15 17输出：340输入：35 2 10 62 7 12 108 1 15 15输出：128</code></pre><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>本题是一道线段树+扫描线的很经典的题目，代码较为复杂，但是也有一个简便但是低效的做法就是用一个数组将所有的区域都表示出来，然后每输入一个区域就将该区域所有点标记上，最后统计所有点数即可。由于内容较多，因此会单独出来分析。</p><h1 id="2017省赛总结"><a href="#2017省赛总结" class="headerlink" title="2017省赛总结"></a>2017省赛总结</h1><p>2017年分体考点如下：</p><ol><li><p>迷宫</p><p>暴力dfs</p></li><li><p>跳蚱蜢</p><p>bfs</p></li><li><p>魔方状态</p><p>模拟过程+判重</p></li><li><p>方块分割</p><p>图形 dfs 模拟过程</p></li><li><p>字母组串</p><p>递归</p></li><li><p>最大公共子串</p><p>dp</p></li><li><p>正则问题</p><p>dfs 模拟过程 抽象</p></li><li><p>包子凑数</p><p>数学问题 扩展欧几里得</p></li><li><p>分巧克力</p><p>二分搜索</p></li><li><p>油漆面积</p><p>线段树+扫描线</p></li></ol><p>2017年的省赛题目整体做下来其实感觉稍微有些难度，没有了往年的前两题的送分题，后面也越来越重视对一些特定算法，数学知识以及代码能力的考查，但是其实大部分题还是用的是暴力求解的思路。从这些题目中也能学到很多经验，比如对于一些题目可能就没有什么特殊的解法，只需要模拟出题目描述的过程就可以；还有一些题目考察的是一些数学问题，这方面需要学习一下；另外遇到一些难题暂时想不出解答时，可以直接用暴力解法获得一部分分数。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> write-up </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集解决无向图的连通性问题</title>
      <link href="/posts/30317.html"/>
      <url>/posts/30317.html</url>
      
        <content type="html"><![CDATA[<p>最近遇到一道无向图的连通性相关的问题。一般解决图相关的问题，最直接的思路就是利用dfs暴力搜索，因为图可以看成是一种特殊的树。但是在查看题解的时候，发现了另一种巧妙的解法。正是利用上一篇所讲到的并查集来优化暴力的dfs算法。下面看具体题目。</p><pre><code>问题描述　　小明的实验室有N台电脑，编号1~N。原本这N台电脑之间有N-1条数据链接相连，恰好构成一个树形网络。在树形网络上，任意两台电脑之间有唯一的路径相连。　　不过在最近一次维护网络时，管理员误操作使得某两台电脑之间增加了一条数据链接，于是网络中出现了环路。环路上的电脑由于两两之间不再是只有一条路径，使得这些电脑上的数据传输出现了BUG。　　为了恢复正常传输。小明需要找到所有在环路上的电脑，你能帮助他吗？输入格式　　第一行包含一个整数N。　　以下N行每行两个整数a和b，表示a和b之间有一条数据链接相连。　　对于30%的数据，1 &lt;= N &lt;= 1000　　对于100%的数据, 1 &lt;= N &lt;= 100000， 1 &lt;= a, b &lt;= N　　输入保证合法。输出格式　　按从小到大的顺序输出在环路上的电脑的编号，中间由一个空格分隔。样例输入51 23 12 42 55 3样例输出1 2 3 5</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>并查集的原理很简单，具体可以看上一篇文章，这里就不再赘述了。我们重点分析为什么并查集可以解决这个问题。</p><p>当并查集录入图的每一条边的时候，都会将这个边的两个节点的根更新一次；又由于这是一张无向连通图，因此所有节点之间都是相互连同的，即最后的根只会有一个值。当新加入的一条边的两个节点的根值相等的时候，就说明这两个节点都曾经作为某条边的端点加入过并查集里了。即 即使不加入这条边，这两个节点之间仍然是连同的。此时再加入一条边，就说明有两条路径可以从a点到b点，即出现了环。下面给出具体的代码。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-python"><code class="language-python">maxn <span class="token operator">=</span> <span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span>par <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>maxn <span class="token comment" spellcheck="true"># 并查集</span>vis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>maxn <span class="token comment" spellcheck="true"># 记录是否遍历过</span>ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>maxn <span class="token comment" spellcheck="true"># 结果集</span>edge <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>maxn<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 存储每个节点相连的边</span>res <span class="token operator">=</span> <span class="token string">''</span><span class="token keyword">def</span> <span class="token function">find_root</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> par<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> v<span class="token punctuation">:</span>        par<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> find_root<span class="token punctuation">(</span>par<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> par<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># u:当前节点 idx: 结果计数 f:终点</span>    <span class="token keyword">global</span> ret<span class="token punctuation">,</span> res     ret<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> u <span class="token comment" spellcheck="true"># 当前节点加入结果集</span>    <span class="token keyword">if</span> u <span class="token operator">==</span> f<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 当前节点就是终点 环遍历完成 输出答案</span>        ret <span class="token operator">=</span> ret<span class="token punctuation">[</span><span class="token punctuation">:</span>idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>        ret<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> res <span class="token operator">+</span> str<span class="token punctuation">(</span>ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token string">' '</span> <span class="token keyword">if</span> i<span class="token operator">!=</span>idx <span class="token keyword">else</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>           <span class="token keyword">return</span>    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 还没到重点 标记当前节点</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 遍历当前节点的所有边</span>        v <span class="token operator">=</span> edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token operator">not</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 这条边没有遍历过</span>                dfs<span class="token punctuation">(</span>v<span class="token punctuation">,</span> idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span>    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 回溯</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        par<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>        u<span class="token punctuation">,</span> v <span class="token operator">=</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        root_u <span class="token operator">=</span> find_root<span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 并查集 搜索根</span>        root_v <span class="token operator">=</span> find_root<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">if</span> root_u <span class="token operator">==</span> root_v<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 两节点根相同</span>            s <span class="token operator">=</span> u <span class="token comment" spellcheck="true"># 搜索起点</span>            f <span class="token operator">=</span> v <span class="token comment" spellcheck="true"># 搜索终点</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 不相同 进行合并操作</span>            par<span class="token punctuation">[</span>root_u<span class="token punctuation">]</span> <span class="token operator">=</span> root_v            edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>            edge<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>u<span class="token punctuation">)</span>    dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过这道题，让我对并查集的理解又加深了一个层次，并且让我对图的连通性有了新的理解。因此我很好奇并查集到底还有哪些常见的用处。</p><p>经过一番资料查找，总结如下：</p><ol><li><p>基本作用 多个不相交集合</p></li><li><p>无向图的连通性（两点之间是否连通）</p></li><li><p>判断无向图中的环</p></li><li><p>最小生成树的Kruskal 算法</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> dfs </tag>
            
            <tag> 无向图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对局匹配</title>
      <link href="/posts/36743.html"/>
      <url>/posts/36743.html</url>
      
        <content type="html"><![CDATA[<h1 id="对局匹配"><a href="#对局匹配" class="headerlink" title="对局匹配"></a>对局匹配</h1><p>最近遇到这样一道题目：</p><pre><code>小明喜欢在一个围棋网站上找别人在线对弈。这个网站上所有注册用户都有一个积分，代表他的围棋水平。小明发现网站的自动对局系统在匹配对手时，只会将积分差恰好是K的两名用户匹配在一起。如果两人分差小于或大于K，系统都不会将他们匹配。现在小明知道这个网站总共有N名用户，以及他们的积分分别是A1, A2, ... AN。小明想了解最多可能有多少名用户同时在线寻找对手，但是系统却一场对局都匹配不起来(任意两名用户积分差不等于K)？  输入第一行包含两个个整数N和K。第二行包含N个整数A1, A2, ... AN。  对于30%的数据，1 &lt;= N &lt;= 10对于100%的数据，1 &lt;= N &lt;= 100000, 0 &lt;= Ai &lt;= 100000, 0 &lt;= K &lt;= 100000输出一个整数，代表答案。样例输入10 01 4 2 8 5 7 1 4 2 8样例输出6</code></pre><p>刚拿到这道题，我的第一感觉就是这是一道动态规划类型的题目。为什么这么说呢，因为当我们求出最多有k个人的时候，如果想求k+1人是否可行的话，必然会存在很多的重复计算，再加之直觉的判断，我断定它是一道动态规划的题目。仅仅做到这一点还远远不够，仔细分析题目，会发现这个题目和以前求leetcode打家劫舍问题有点类似，但是却又不太一样。</p><p>本题的关键在于“系统却一场对局都匹配不起来(任意两名用户积分差不等于K)”这个条件，即任意两个相隔为k的用户不能够同时上线。题中给出的数据是N个用户的分数数据，并不能直接看出本题的状态转移。因此，在分析本题的状态转移之前，我们要对原始数据进行一定的处理。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>由于条件是任意两个差值为k的用户都不能同时存在，本题其实就是在求不同分值同时在线的情况，即相同分值的用户是等效的。因此，我们可以先将用户按照分数统计出来并分类。我们用一个MAX_SCORE大小的数据来记录即可。现在我们得到了所有用户的分数统计。下一步，我们将相互排斥的用户分到一组然后利用dp求取最优解。即：</p><pre><code>{0, k, 2k, 3k...} 相互排斥的用户分为一组，利用dp求最优解。{1, k+1, 2k+1, 3k+1...} 任意两组之间的用户不排斥，因此最终答案是每组的最优解相加即可{2, k+2, 2k+2, 3k+2...}...{k-1, k+k-1, 2k+k-1, 3k+k-1...}</code></pre><p>对数据处理完毕，接下来我们就可以对每组数据进行动态规划了。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>对于动态规划问题，我们还是按照前文的方法来做，一步一步进行分析。</p><h3 id="明确dp数组含义"><a href="#明确dp数组含义" class="headerlink" title="明确dp数组含义"></a>明确dp数组含义</h3><p>我们要求解的问题是当前组能够同时上线的用户数量，所以我们的dp数组含义就应该是当前最大用户数量。因此<code>dp[i]</code>定义为<code>val[0…i]</code>的最大用户数量。</p><h3 id="明确当前的选择"><a href="#明确当前的选择" class="headerlink" title="明确当前的选择"></a>明确当前的选择</h3><p>当我们把问题缩小到每一组时，我们可以发现这个问题的本质条件就是每一组相邻的两个分数不能同时选择，这里就和打家劫舍问题类似了，因此当前的选择也很简单，就是是否选择当前的分数；如果选择了当前分数，就不能选择前一个<code>dp[i] = dp[i-2]+val[i]</code>, 若不选择就是<code>dp[i] = dp[i-1]</code>。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>这里状态转移方程就很容易给出了：<code>dp[i] = max(dp[i-2]+val[i], dp[i-1])</code></p><h3 id="base-case"><a href="#base-case" class="headerlink" title="base case"></a>base case</h3><p>本题的base case就是第一个的时候，由于没有选择，<code>dp[0] = [0]</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>至此，问题的核心就分析完毕了，下面给出代码实现，具体细节在注释中阐述。</p><pre class="line-numbers language-python"><code class="language-python">MAX_SCORE <span class="token operator">=</span> <span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span>MAXN <span class="token operator">=</span> <span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span>cnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> MAXSCOREval <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> MAXNdp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> MAXNans <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 最终答案</span><span class="token comment" spellcheck="true">#对应蓝桥杯数据输入部分</span>tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>n<span class="token punctuation">,</span> k <span class="token operator">=</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 数据预处理</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    cnt<span class="token punctuation">[</span>int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># k=0的情况特殊处理</span><span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>MAX_SCORE<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            ans <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>        m <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#每一组个数的计数变量</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> MAX_SCORE<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#将当前一组的数据单独拿出来 即分组操作</span>               val<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># val 中存储的就是当前组的数据</span>            m <span class="token operator">+=</span> <span class="token number">1</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># base case</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 状态转移</span>            <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 状态转移方程</span>            ans <span class="token operator">+=</span> dp<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 每组的最优解累加</span><span class="token keyword">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这道题本身的动态规划过程并不困难，主要难点在于如何想到利用动态规划的方法来解决问题。又由于本题并不是直接的动态规划类的题目，需要进行一定处理才可以利用动态规划来解决。这也就说用需要对问题进行合理的转化。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/posts/61809.html"/>
      <url>/posts/61809.html</url>
      
        <content type="html"><![CDATA[<p>最近看到一道这样的蓝桥杯题目：</p><pre><code>问题描述　　w星球的一个种植园，被分成 m * n 个小格子（东西方向m行，南北方向n列）。每个格子里种了一株合根植物。　　这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。　　如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？输入格式　　第一行，两个整数m，n，用空格分开，表示格子的行数、列数（1&lt;m,n&lt;1000）。　　接下来一行，一个整数k，表示下面还有k行数据(0&lt;k&lt;100000)　　接下来k行，第行两个整数a，b，表示编号为a的小格子和编号为b的小格子合根了。　　格子的编号一行一行，从上到下，从左到右编号。　　比如：5 * 4 的小格子，编号：　　1 2 3 4　　5 6 7 8　　9 10 11 12　　13 14 15 16　　17 18 19 20样例输入5 4162 31 55 94 87 89 1010 1111 1210 1412 1614 1817 1815 1919 209 1313 17样例输出5</code></pre><p>题目一眼看上去并不困难，最直观的想法是用DFS暴力搜索一下，搜索过的地方标记一下即可找出共有多少连根植物。按照这个思路写了一下，结果只通过66%。然后看了一下解答，结果用的是并查集来解决这个问题。由于本身对这种数据结构使用的并不是很多而且不是很熟练，所以没有第一时间想到这个解法。在这里详细记录一下并查集的使用以及本题的解法。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集通过维护一个一维数组来实现，其本质是一个森林。刚开始每个节点都是孤立的，根就是自己。之后通过一些条件逐渐合并。用于处理一些不交集的合并及查询问题。 有一个联合-查找算法定义了两个用于此数据结构的操作： Find ：确定元素属于哪一个子集。 它可以被用来确定两个元素是否属于同一子集。</p><h2 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h2><p>下面直接看代码，在代码里一步步进行分析。</p><pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token comment" spellcheck="true">#定义并查集</span><span class="token keyword">def</span> <span class="token function">init</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token comment" spellcheck="true">#初始话并查集，每个节点的根是自己</span><span class="token keyword">def</span> <span class="token function">find_root</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> v <span class="token operator">==</span> f<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果当前节点的值就是自己的话，代表当前节点就是这棵树的根</span>        <span class="token keyword">return</span> v <span class="token comment" spellcheck="true"># 直接返回即可</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> find_root<span class="token punctuation">(</span>f<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 如果不是，说明f[v]存的值只是中间节点，那么就去找f[v]的根，顺便                                # 将当前节点的值改成根的值 这是一个递归的过程</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 返回最后找到的根的值</span><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>    t1 <span class="token operator">=</span> find_root<span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># u的根是t1</span>    t2 <span class="token operator">=</span> find_root<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># v的根是t2</span>    <span class="token keyword">if</span> t1 ！<span class="token operator">=</span> t2<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果根相同，则这两个节点已经是同根了，不需要继续操作；如果不同，则需要合并</span>        f<span class="token punctuation">[</span>t2<span class="token punctuation">]</span> <span class="token operator">=</span> t1 <span class="token comment" spellcheck="true"># 不同的话，我们只需要将v的根t2的根（f[t2]的值）改成t1即可，表示t2的根是t1，                    # 这样t2下面所有节点就都属于t1了；这里其实用 f[t1] = t2也是一样的效果。</span><span class="token comment" spellcheck="true"># 并查集的核心算法就是这些，其实很简单，下面就是针对具体题目了</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 对于上述题目:</span>    input_tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>    m<span class="token punctuation">,</span> n <span class="token operator">=</span> int<span class="token punctuation">(</span>input_tmp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>input_tmp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    size <span class="token operator">=</span> m<span class="token operator">*</span>n    init<span class="token punctuation">(</span>size<span class="token punctuation">)</span>    cmd_num <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> cmd_num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        input_tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>        x<span class="token punctuation">,</span> y <span class="token operator">=</span> int<span class="token punctuation">(</span>input_tmp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>input_tmp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        merge<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 最后找出有几个根，就是有几个不相交集，即答案</span>        <span class="token keyword">if</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">:</span>            s <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>算法倒是不难，只是一时没有想到。另外最近几天都没有更新啦，确实有一部分的原因在于我又摸鱼了，但是! 但是！最近事情也确实比较多，参与了一个5k star的大项目，又在整一下简历，另外其实我是正在写另一篇文章的。是关于linux部署的文章，但是在写文章复现的时候出现了一些莫名其妙的bug，折腾了两天都没有进展就卡住了，于是只好先弃坑，整理一下这个相对简单的问题，然后我打算完全重装一下服务器，重新实验一下，可能还需要几天，大概就是这样。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python import用法总结</title>
      <link href="/posts/52811.html"/>
      <url>/posts/52811.html</url>
      
        <content type="html"><![CDATA[<p>最近写代码的时候又遇到了Import出错的问题，以前遇到这类问题总是赶紧Google一下，尽快找到解决方案，最近又遇到了这个问题，小小的研究了一下，借这个机会稍微总结一下import的用法。</p><h1 id="python-import原理"><a href="#python-import原理" class="headerlink" title="python import原理"></a>python import原理</h1><p>要想用根本上解决这个问题，就必须了解import的工作原理。稍微Google了一些，在执行import时分如下几步进行：</p><ol><li>创建一个新的、空的 module 对象（它可能包含多个 module）；</li><li>将该 module 对象 插入 sys.modules 中； </li><li>装载 module 的代码（如果需要，需先编译）； </li><li>执行新的 module 中对应的代码。</li></ol><p>import会出错问题就在于第三步。首先会找到module所在的位置，其搜索顺序是：</p><p>sys.path -&gt; PATHONPATH -&gt; python默认路径。我们最主要使用的就是sys.path了。sys.path是一个list，是import的搜索路径， python程序运行时会自动将该入口程序的所在目录添加到sys.path的首位；然后就是python的第三方库的安装路径。如图所示：<img src="image-20200227102200604.png" alt="sys.path"></p><p>因为这个机制，就产生了很多的问题。当程序比较大的时候，因此import只关心入口程序的path以及第三方库，所以在使用一些自定义的package时就会出现无法找到的错误。</p><h1 id="import的几种不同的使用情况"><a href="#import的几种不同的使用情况" class="headerlink" title="import的几种不同的使用情况"></a>import的几种不同的使用情况</h1><h2 id="同级目录-不在包内"><a href="#同级目录-不在包内" class="headerlink" title="同级目录 不在包内"></a>同级目录 不在包内</h2><p>项目结构如图所示：</p><p><img src="image-20200227102753355.png" alt="1"></p><p>这里file0.py和file01.py是在项目的根目录，也就是最简单的情况</p><p>代码分别如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># file0.py</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># file01.py</span><span class="token keyword">from</span> file0 <span class="token keyword">import</span> a<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码非常简单，两个文件在同级根目录下，运行成功。</p><h2 id="同级目录下的包"><a href="#同级目录下的包" class="headerlink" title="同级目录下的包"></a>同级目录下的包</h2><p>结构如图：</p><p><img src="image-20200227111328629.png" alt="2"></p><p>代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># file0.py</span><span class="token keyword">from</span> test1 <span class="token keyword">import</span> file1file1<span class="token punctuation">.</span>pr<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># test1/file1.py</span><span class="token keyword">def</span> <span class="token function">pr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况是比较常用的情况，file0.py作为入口函数，调用其子目录的包里的module。代码运行成功</p><h2 id="隔壁目录下的包文件"><a href="#隔壁目录下的包文件" class="headerlink" title="隔壁目录下的包文件"></a>隔壁目录下的包文件</h2><p>结构如图：</p><p><img src="image-20200227111734521.png" alt="image-20200227111734521"></p><p>代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># test1/file1.py</span><span class="token keyword">def</span> <span class="token function">pr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># test2/file2.py</span><span class="token keyword">from</span> test1 <span class="token keyword">import</span> file1file1<span class="token punctuation">.</span>pr<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行代码发生错误：</p><p><img src="image-20200227113131442.png" alt="image-20200227113131442"></p><p>分析一下原因，由于import是根据sys.path来搜索的，而sys.path添加的又是入口程序的目录，在当前目录下当然找不到同级文件夹了。在入口代码加上输出sys.path的代码，结果如下：</p><p><img src="image-20200227113807211.png" alt="image-20200227113807211"></p><p>我们看到第一个路径就是当前入口程序的所在目录，与之前分析符合。</p><p>如何解决这个问题？既然知道了import的工作原理，最直接的想法就是把test1的路径加到sys.path里，但是不太好实现；退一步，我们只要把test2和test1的父目录加到sys.path里就可以了。修改代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># test1/file1.py</span><span class="token keyword">def</span> <span class="token function">pr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># test2/file2.py</span><span class="token keyword">import</span> syssys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'..'</span><span class="token punctuation">)</span><span class="token keyword">from</span> test1 <span class="token keyword">import</span> file1file1<span class="token punctuation">.</span>pr<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行成功。</p><h2 id="复杂情况"><a href="#复杂情况" class="headerlink" title="复杂情况"></a>复杂情况</h2><p>文件结构不变：</p><p><img src="image-20200227111734521.png" alt="image-20200227111734521"></p><p>代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># test2/file2.py</span><span class="token keyword">import</span> syssys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'..'</span><span class="token punctuation">)</span><span class="token keyword">from</span> test1 <span class="token keyword">import</span> file1file1<span class="token punctuation">.</span>pr<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># test1/file1.py</span><span class="token keyword">import</span> file11<span class="token keyword">def</span> <span class="token function">pr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>file11<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># test1/file11.py</span><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行代码，出现错误:<img src="image-20200227120531593.png" alt="image-20200227120531593"></p><p>在这里上一个方法就行不通了，分析一下：</p><p>入口文件还是file2.py，因此sys.path里应该有test2文件夹，我们又手动加入了’..’，因此还包括了test2的父文件夹。因此，我们<code>from test1 import file1</code>成功了；接下来，在file1里，我们想要import同级module file11.py 。我们直接使用<code>import file11</code>，看起来是没有问题的，但是程序也就是在这里报了错。分析一下，因为我们是直接使用的<code>import file11</code>操作，也就是直接在sys.path中搜索file11，当然是搜索不到的。想要使用到file11，sys.path必须要包含test1路径。</p><p>找到了问题的所在，我们只要对症下药即可。我们再把test1的路径加入sys.path不就可以了。</p><p>代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># test1/file1.py</span><span class="token keyword">import</span> sys<span class="token punctuation">,</span> osBASE_DIR <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>__file__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>BASE_DIR<span class="token punctuation">)</span>sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>BASE_DIR<span class="token punctuation">)</span><span class="token keyword">import</span> file11<span class="token keyword">def</span> <span class="token function">pr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>file11<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下，就是在这个包的入口文件处，将这个包的目录加入到sys.path中即可。这里添加的是绝对路径，因此在其他位置调用该包也可以正常工作。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>基本上常见的情况就是这些了，其实对于这些问题，有一个更加简便的方法：使用pycharm pycharm在使用的时候，会自动把项目的根目录加到sys.path里，上述问题自动解决🤪（pycharm真相）所以说写项目的时候还是用pycharm吧！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划解KMP算法</title>
      <link href="/posts/59750.html"/>
      <url>/posts/59750.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划解KMP算法"><a href="#动态规划解KMP算法" class="headerlink" title="动态规划解KMP算法"></a>动态规划解KMP算法</h1><p>KMP算法是一个非常经典的字符串匹配算法，效率很高，其原因也在于使用了动态规划的设计思想，但是着实复杂。。为了更加便于理解，本文采用的是一种二维dp数组的方式，而不是一般资料里非常神奇的一维数组（水平有限，菜），但是问题的复杂度并没有上升。下面看问题描述：</p><pre><code>pat 表示模式串，长度为 M，txt 表示文本串，长度为 N。KMP 算法是在 txt 中查找子串 pat，如果存在，返回这个子串的起始索引，否则返回 -1。</code></pre><p>问题倒是很简单，如果用暴力算法解决，时间复杂度则是 $$ O(M*N)$$,  显然不现实。在解决这个问题的过程中，我发现这个问题对状态分析的过程非常经典，其他资料更加直接，直接使用DFA来解决这个问题。在我看来动态规划和DFA有着异曲同工之妙，也可以说本题就是DFA的代码实现，其他类似问题完全可以套用。废话不多说，下面开始分析。</p><h2 id="1-确定问题的状态与dp数组"><a href="#1-确定问题的状态与dp数组" class="headerlink" title="1. 确定问题的状态与dp数组"></a>1. 确定问题的状态与dp数组</h2><p>在暴力解法中，影响时间复杂度的最大原因就是搜索指针只是在盲目的穷举所有的情况，其中包括一些没有意义的情况。如果能解决这个问题，那么算法的时间复杂度就会很大的提高。</p><p>对于pat和txt来说，pat是固定的，而txt却是任意的。他们的共同点就是要在txt里匹配出pat，因此我们选择用相对固定的pat来设计有限的状态（好吧其实是书上说要用DFA的我也不太明白为啥就不瞎BB了）。</p><p>回想计算理论学习的DFA设计正规文法，我们可以用类似的思路来设计这个问题的状态。即按照pat的字符串的顺序,每一个字符都是一个状态(即当txt每多匹配一个字符，就是一个不同的状态)。那么按照这个思路，dp数组里记录的就是各个状态之间的转移关系了。要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符。因此，我们定义dp数组为：<code>dp[j][c] = next</code>，其中j代表当前状态，C代表当前的字符（用asc码表示，或者用字典实现）。举例来说，<code>dp[4]['A'] = 3</code>含义就是，在状态4时，匹配到了字符A，于是要跳转到状态３即可。有了这个定义，我们可以很容易的实现搜索操作。</p><h2 id="2-明确当前的选择"><a href="#2-明确当前的选择" class="headerlink" title="2. 明确当前的选择"></a>2. 明确当前的选择</h2><p>从暴力解法来看，如果当前字符c和pat[i]是匹配的，那就转移到下一个状态；如果不匹配，那么就转移到另一个状态。因此选择就是根据当前字符串c进行状态的转移。</p><h2 id="3-构建状态方程（DFA）"><a href="#3-构建状态方程（DFA）" class="headerlink" title="3. 构建状态方程（DFA）"></a>3. 构建状态方程（DFA）</h2><p>在前面的分析中，当c和pat[i]不匹配时，我们说应该转移到另一个状态，那么这个状态到底应该如何确定呢？</p><p>这里就涉及到一个编程的小技巧。当遇到不匹配的情况时，搜索指针就要进行回退，在暴力算法中会同时回退pat指针和txt指针。为了减少时间复杂度，我们可以利用dp数组中存储的信息，来确定回退的具体位置。具体来说，就是用一个变量来记录当前状态的上一个相同前缀的状态即可，记为X。当前状态如果不能匹配的话，就去询问状态X ，应该如何跳转即可。因为状态X在之前已经计算过了（动态规划）。</p><h2 id="4-base-case分析"><a href="#4-base-case分析" class="headerlink" title="4. base case分析"></a>4. base case分析</h2><p>本问题中，当任何字符都没有匹配的时候，我们设定为状态0，那么在状态0下，只有匹配到pat的第一个字符才能继续推进状态，即base case就是<code>dp[0][pat[0]]=1;</code></p><h2 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5. 代码实现"></a>5. 代码实现</h2><p>下面给出具体的完整代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">KMP</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pat<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>pat <span class="token operator">=</span> pat        M <span class="token operator">=</span> len<span class="token punctuation">(</span>pat<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">256</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>ord<span class="token punctuation">(</span>pat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        X <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># for c in range(256):</span>                <span class="token comment" spellcheck="true"># if ord(pat[j]) == c:</span>                   <span class="token comment" spellcheck="true"># self.dp[j][c] = j+1</span>                   <span class="token comment" spellcheck="true">#else:</span>                <span class="token comment" spellcheck="true">#    self.dp[j][c] = self.dp[X][c]</span>            <span class="token comment" spellcheck="true">#X = self.dp[X][ord(pat[j])]</span>               <span class="token keyword">for</span> c <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>ord<span class="token punctuation">(</span>pat<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span>            X <span class="token operator">=</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">[</span>ord<span class="token punctuation">(</span>pat<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> txt<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        M <span class="token operator">=</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>pat<span class="token punctuation">)</span>        N <span class="token operator">=</span> len<span class="token punctuation">(</span>txt<span class="token punctuation">)</span>        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>ord<span class="token punctuation">(</span>txt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> j <span class="token operator">==</span> M<span class="token punctuation">:</span>                <span class="token keyword">return</span> i <span class="token operator">-</span> M <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> leetcode </tag>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间调度</title>
      <link href="/posts/55741.html"/>
      <url>/posts/55741.html</url>
      
        <content type="html"><![CDATA[<h1 id="区间调度之贪心算法解法"><a href="#区间调度之贪心算法解法" class="headerlink" title="区间调度之贪心算法解法"></a>区间调度之贪心算法解法</h1><p>区间调度问题，或者说是活动安排问题，在实际中用途非常广泛。解决这个问题的核心思想其实比较简单，可以说是一种贪心算法的思想，是贪心算法的一个很典型的应用。这里主要记录一些和解决这个问题相关的问题。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>首先看一下问题描述：</p><p><code>给你很多形如 `[start, end]` 的闭区间，请你设计一个算法，**算出这些区间中最多有几个互不相交的区间**。</code></p><p>这种问题可能有很多的说法，比如活动安排，开会，重叠区间等等，但是本质上都是这样一个问题。这种问题的解法在学校也早已学过了，这里就不在多去分析。</p><p>解决该类问题的一个非常有效的步骤就是：</p><ol><li>首先将所有区间按照 <code>end</code>进行排序</li><li>选择end最小的区间 x，将所有与x重合的区间删除</li><li>重复上述过程，知道所有区间都被选择（删除），选出的x就是最大不相交区间</li></ol><p>到这里，问题就已经被解决了，再有类似的问题也不过是在这个思路的基础上变化一下。但是我在实际的编码过程中却遇到了一些问题。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>由于我是最近才选择用python来做算法题，所以对python这方面相关的函数还是不够了解，在这里便遇到了一个坑处。在C++里，我们想对sort函数进行自定义，只需要自己定义一个函数，来描述出所想要的“大小关系”即可。但是在python里却不是这么实现的。</p><h3 id="python的sorted函数"><a href="#python的sorted函数" class="headerlink" title="python的sorted函数"></a>python的sorted函数</h3><p>在遇到上述问题后，我大概的收集了一下资料。我发现在python2里，sorted函数的用法还是和C++是相同的，但是在python3里却进行了改变（据说是可以提高性能，但是都用python了还讲啥性能.jpg）。在python3的sorted函数中，原来接受比较函数的参数改为了<code>key</code>参数。这个参数只接受 一个单参数的函数作为参数（此处可能比较绕，具体代码解释），因此需要接触python的functools包来解决这个问题。看具体代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">cmp</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> list<span class="token punctuation">,</span> b<span class="token punctuation">:</span>list<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 一般的比较函数 在此处定义“大小关系”即可</span>    <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>l <span class="token operator">=</span> sorted<span class="token punctuation">(</span>l<span class="token punctuation">,</span> key<span class="token operator">=</span>functools<span class="token punctuation">.</span>cmp_to_key<span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># key参数只接受一个单参数的函数 functools.cmp_to_key()将cmp函数转化为一个单参数的函数，换句话说，将list l 中的所有元素都转化成了按照cmp关系定义的可比较的元素。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询到的资料是这样描述的：</p><p><code>functools.cmp_to_key(func)</code>将老式的比较函数（comparison function）转化为关键字函数（key function）。与接受 key function 的工具一同使用（如 sorted(), min(), max(), heapq.nlargest(), itertools.groupby())。该函数主要用来将程序转成 Python 3 格式的，因为 Python 3 中不支持比较函数。比较函数是可调用的，接受两个参数，比较这两个参数并根据他们的大小关系返回负值、零或正值中的某一个。关键字函数也是可调用的，接受一个参数，同时返回一个可以用作排序关键字的值。</p><p>到这里这个问题才算完全解决了，下面给出这个问题的完整代码，也可以作为其他类似问题的一个模板或者基础。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">cmp</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> list<span class="token punctuation">,</span> b<span class="token punctuation">:</span> list<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">intervalSchedule</span><span class="token punctuation">(</span>intvs<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>intvs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    intvs <span class="token operator">=</span> sorted<span class="token punctuation">(</span>intvs<span class="token punctuation">,</span> key<span class="token operator">=</span>functools<span class="token punctuation">.</span>cmp_to_key<span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token punctuation">)</span>    count <span class="token operator">=</span> <span class="token number">1</span>    x_end <span class="token operator">=</span> intvs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> inter <span class="token keyword">in</span> intvs<span class="token punctuation">:</span>        start <span class="token operator">=</span> inter<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> start <span class="token operator">></span> x_end<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>            x_end <span class="token operator">=</span> inter<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最近两天都没有更新，实属偷懒了哈哈哈（netflix.jpg)真香。在家学习总是没有效率，每次连续的学习时间都不会超过半个小时，我想主要是因为没有显示器的原因吧hhh 只能说是尽量改变吧 在家 能学多少学多少😁</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 区间调度 </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> 活动安排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>石头游戏</title>
      <link href="/posts/49424.html"/>
      <url>/posts/49424.html</url>
      
        <content type="html"><![CDATA[<h1 id="博弈问题之石头游戏的动态规划解法"><a href="#博弈问题之石头游戏的动态规划解法" class="headerlink" title="博弈问题之石头游戏的动态规划解法"></a>博弈问题之石头游戏的动态规划解法</h1><p>最近遇到这样一个问题：</p><p><code>你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头  piles = [1, 100, 3]，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。假设两人都很聪明，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。</code></p><p>其实这个问题有很多的变种，比如leetcode上的海盗分宝石问题，蓝桥杯里的和尚上楼梯问题等等，都是博弈问题的一种。今天就借这个机会，以石头游戏这个问题为例学习一下这类问题的动态规划解法。</p><h2 id="1-确定问题的状态"><a href="#1-确定问题的状态" class="headerlink" title="1. 确定问题的状态"></a>1. 确定问题的状态</h2><p>对于本问题而言，最重要的状态就是石头堆的情况了。因此当前石头堆数组的开始和结束索引就是本题的状态量。其次，当前时间轮到谁来选择也很重要，这就是问题的另一个状态，先后手。</p><h2 id="2-确定dp数组含义"><a href="#2-确定dp数组含义" class="headerlink" title="2. 确定dp数组含义"></a>2. 确定dp数组含义</h2><p>对于这里博弈问题，如果想要用动态规划的方法来解决，最关键的就是要用dp数组记录下博弈双方各自的状态。根据前面的分析，我们可以用一个三维dp数组来记录本题的状态。为了方便起见，在解题时我定义了一个数据结构:</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> fir<span class="token punctuation">,</span> sec<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>fir <span class="token operator">=</span> fir        self<span class="token punctuation">.</span>sec <span class="token operator">=</span> sec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其本质上还是一个三维数组。因此dp数组就为一个二维数组，其含义为：dp[i] [j].fir表示在石头堆piles[i…j]的情况下，先手的人可以得到的最多分数，其他情况以此类推。</p><h2 id="3-写出状态转移方程"><a href="#3-写出状态转移方程" class="headerlink" title="3. 写出状态转移方程"></a>3. 写出状态转移方程</h2><p>在本问题中，选择都很简单，只要选择石头堆两端最大的就可以了。因此问题的关键不是在选择上，而是如何表示出博弈双方都选择当前情况的最优解（两人轮流选择）的这种状态变化。</p><p>我们先分析先手：当现在面对石头堆piles[i…j]时，当然是选择<code>max(piles[i], piles[j])</code>，这一点很容易想到。假设我选择了piles[i], 那么当轮到后手选择的时候，此时的后手就相当于“先手”,   即:                                   <code>dp[i][j].sec=dp[i+1][j].fir</code>, 而先手在这一轮就相当于“后手”，于是便有<code>dp[i][j] = dp[i+1] [j].sec + piles[i]</code>。其他情况也是类似。</p><p>到这里我们就遇到问题的难点了，我们之前一直都是在分析每种情况单独存在的状态转移，但是先手的选择会对后手有影响，所以最终应该如何表示博弈双方的轮流选择呢？</p><p>为了解决这个问题，充分表现出先手对后手产生的影响，我们选择分别计算出先手选了左端的情况和右端的情况，分开来进行分析，最终完成dp数组的推演。</p><h2 id="4-base-case"><a href="#4-base-case" class="headerlink" title="4. base case"></a>4. base case</h2><p>本题的base case 还是比较容易找到的，由于dp数组的定义，因此base case 就是当i==j时，此时先手一定得分为piles[i]，而后手一定得分为0。</p><h2 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5. 代码实现"></a>5. 代码实现</h2><p>到这里，问题的分析部分就结束了，下面给出石头游戏问题的代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> fir<span class="token punctuation">,</span> sec<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>fir <span class="token operator">=</span> fir        self<span class="token punctuation">.</span>fir <span class="token operator">=</span> sec<span class="token keyword">def</span> <span class="token function">stoneGame</span><span class="token punctuation">(</span>piles<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>piles<span class="token punctuation">)</span>    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>node<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span>n <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fir <span class="token operator">=</span> piles<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sec <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            p <span class="token operator">=</span> j            q <span class="token operator">=</span> i<span class="token operator">+</span>j            left <span class="token operator">=</span> pile<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>sec            right <span class="token operator">=</span> pile<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sec               <span class="token keyword">if</span> left <span class="token operator">></span> right<span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>fir <span class="token operator">=</span> left                dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>sec <span class="token operator">=</span> dp<span class="token punctuation">[</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>fir            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>fir <span class="token operator">=</span> right                dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>sec <span class="token operator">=</span> dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fir    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fir <span class="token operator">-</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此类问题大多具有共性，最主要的问题在于如何设计dp数组来存储博弈双方的状态，以及如何来表示博弈双方轮流选择时对后续选择的影响的。只要能把握好这两点，一般的博弈问题按照这种动态规划的思路来解决就没有什么大的问题了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 博弈问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑距离问题</title>
      <link href="/posts/50800.html"/>
      <url>/posts/50800.html</url>
      
        <content type="html"><![CDATA[<h1 id="编辑距离问题之动态规划解法"><a href="#编辑距离问题之动态规划解法" class="headerlink" title="编辑距离问题之动态规划解法"></a>编辑距离问题之动态规划解法</h1><p>在leetcode上遇到一道很有意思的题目：编辑距离问题。这也是一道字符串处理类型的题目，并且是求最值，很容易想到用动态规划来解决这个问题。直接看题目<img src="image-20200219151029939.png" alt=""></p><p>题目本身不难理解，但是细想还是存在很多有疑问的地方的。下面一步一步分析。</p><h2 id="1-确定问题状态和dp数组含义"><a href="#1-确定问题状态和dp数组含义" class="headerlink" title="1. 确定问题状态和dp数组含义"></a>1. 确定问题状态和dp数组含义</h2><p>对于这个问题来说，由于设计到两个字符串，根据经验我们先设dp数组为一个二维的数组，具体含义一会再分析。对于本题来说，由于变化量只有两个字符串，因此状态就是两个字符串的下标了。然后我们再来分析dp数组的具体含义。由于是求最小编辑距离，也就是让s1通过最短的操作步骤变成s2（等效于s2变成1），因此，dp数组可以这样定义：dp[i] [j]的含义为s1[i]变成s2[j]所需要的最小编辑步数。再将这个定义带入分析一下，可以推导出我们最后要的结果，因此dp数组就这样确定下来。</p><h2 id="2-明确选择"><a href="#2-明确选择" class="headerlink" title="2. 明确选择"></a>2. 明确选择</h2><p>题目已经将我们可做的选择都列出来了：</p><ol><li>插入</li><li>删除</li><li>替换</li></ol><p>除了已经列出来的这三个操作，其实还有第四个操作：什么都不做。当s1[i]与s2[j]匹配的时候，当然是什么都不做直接跳过啦，这些就是本题的选择。看起来这一步已经完成了，但其实仔细想想，如何用状态转移来表示这几个选择呢？</p><h2 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3. 状态转移方程"></a>3. 状态转移方程</h2><p>完成了前面的分析，我们便可以开始写状态转移方程了。</p><p>我们先分析匹配的情况：</p><p>当s1[i]和s2[j]匹配时，我们的选择当然是什么都不做，此时dp[i] [j]就取决于前面的操作，即dp[i] [j] = dp[i-1] [j-1];这种情况很容易分析出来。接下来看不匹配的情况。</p><p>当s1[i]和s2[j]不匹配时，我们就要考虑选择题目提供的三种操作的哪一种操作。但是在当前dp数组定义下，每个选择要如何表示呢？</p><h3 id="1-插入"><a href="#1-插入" class="headerlink" title="1.插入"></a>1.插入</h3><p>当我们选择插入操作时，即在s1[i]处插入s2[j]，此时便相当于s2[j]被匹配掉（因为插入的字母一定是等于s2[j]的，而s1相当的长度增加1，即dp[i+1-1]，这是和替换操作的区别所在）此时的dp[i] [j]取决于dp[i] [j-1]。又因为执行了插入操作，故：</p><p><code>dp[i][j] = dp[i][j-1]+1</code></p><h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2.删除"></a>2.删除</h3><p>当选择删除操作时，即s1[i]处删除掉一个字母，s2[j]未被匹配掉，仍保持不变，因此dp[i] [j]就取决于dp[i-1] [j]了，即：</p><p><code>dp[i][j] = dp[i-1][j]+1</code></p><h3 id="3-替换"><a href="#3-替换" class="headerlink" title="3.替换"></a>3.替换</h3><p>当我们选择替换操作时，其实和插入操作有点类似，此时s1[i]被替换为s2[j]，因此s1[i]于s2[j]便匹配了（这里又和直接匹配的情况类似），因此最终结果为：</p><p><code>dp[i][j] = dp[i-1][j-1]+1</code></p><p>到这里，我们只要择优选择就可以了。状态转移方程就全部写出来了，算法的核心代码就是把这一部分翻译成代码语言即可。</p><h2 id="4-base-case"><a href="#4-base-case" class="headerlink" title="4. base case"></a>4. base case</h2><p>一般来说找base case都是顺手就完成的工作，而本题不愧是hard problem，连base case都不是直接能看出来的了。我们带入一个实例分析：当s2遍历完成时，此时s1如果还没有遍历完成，便只能选择插入操作，这应该就是base case了。因此base case就是当两个字符串分别遍历完成时的情况。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面给出两种不同的代码实现：</p><ul><li>dp数组方式</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>    m<span class="token punctuation">,</span> n <span class="token operator">=</span> len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span>    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s2<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> s1<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>                    dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 插入</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 删除</span>                    dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 替换</span>                <span class="token punctuation">)</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>备忘录递归方式</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>    memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> j<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> i <span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token keyword">in</span> memo<span class="token punctuation">:</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            memo<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> memo<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>         <span class="token keyword">else</span><span class="token punctuation">:</span>            memo<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>                dp<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>                dp<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>                dp<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>            <span class="token punctuation">)</span>        <span class="token keyword">return</span> memo<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> dp<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本题算是一道小有难度的动态规划问题了，同时也非常经典。我在做这道题的时候，在几个地方都有卡住。</p><p>首先是关于如何表示题目所给出的三种操作的，这一点确实不太好想到，其次就是关于base case的设置，也不容易想到（数组要设置为dp[m+1] [n+1], dp[0] [0]设为空）。主要原因还是缺乏经验，继续学习！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 备忘录递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长递增子序列</title>
      <link href="/posts/49199.html"/>
      <url>/posts/49199.html</url>
      
        <content type="html"><![CDATA[<h1 id="最长递增子序列之动态规划解法"><a href="#最长递增子序列之动态规划解法" class="headerlink" title="最长递增子序列之动态规划解法"></a>最长递增子序列之动态规划解法</h1><p>最近在leetcode 做了这样一道动态规划的题目，看了答案以后发现并不是非常的困难，但是也困扰了我好久（属实垃圾。。）。过了几天以后再次看这道题，虽说有了一定思路，但是依然没有解决出来（垃圾实锤），特此记录一下这道题的解决过程，应用一下前文所述的框架。</p><p>先看题目：<img src="1.png" alt=""></p><p>题目描述本身并没有什么坑点，也算是一道很典型的动态规划问题（子序列+最大值）。</p><h2 id="1-确定问题的状态和dp数组"><a href="#1-确定问题的状态和dp数组" class="headerlink" title="1. 确定问题的状态和dp数组"></a>1. 确定问题的状态和dp数组</h2><p>首先由于这道题目只是求自身的最长递增子序列，并没有设计到和其他序列进行比较，所以暂时可以确定dp数组是一个一维数组。在这个问题中，没有特别明显的状态，不太方便从这个角度分析。接下来就是考虑dp数据的含义了，既然是一维数组，那么最直接的想法就是dp[i]就表示从nums[0…i]的最大长度（不是说一定从0开始），因为最终的答案肯定是在dp数组中，再结合题目，很容易得出这个定义。带入尝试一下发现没有问题，继续分析。</p><h2 id="2-确定当前的选择"><a href="#2-确定当前的选择" class="headerlink" title="2. 确定当前的选择"></a>2. 确定当前的选择</h2><p>我们假设这样一种情况：现在我们通过某种方式已经求出了dp[i-1]的值，现在我们想要求dp[i]的值。面对这样的情况，我们可以有哪几种选择或者说操作呢？</p><p>首先，求出了dp[i-1]就说明nums[0…i-1]中的最长长度以及有了。现在我们遍历到了nums[i]的位置，那么最直接的想法就是判断是否将nums[i]接到前面的最长序列上。又由于子序列不一定是连续的（即dp[i-1]和dp[i-2]的情况可能不一样），所以到底接在哪个最大子序列上也是一个选择。综合起来，选择就是是否将nums[i]接在nums[0…i-1]中的最长子序列中以及接在哪个一最长子序列中。</p><h2 id="3-写出状态转移方程"><a href="#3-写出状态转移方程" class="headerlink" title="3. 写出状态转移方程"></a>3. 写出状态转移方程</h2><p>明确了dp数组的含义和选择，再结合数学归纳法分析一下，很容易得出该问题的状态转移方程：</p><pre class="line-numbers language-python"><code class="language-python">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-初始话base-case"><a href="#4-初始话base-case" class="headerlink" title="4. 初始话base case"></a>4. 初始话base case</h2><p>本题的base case很好得出，子序列最少也需要包含自己，所以base case就是1。由于dp数组为一维，每次求dp[i] 都需要 dp[0…i]，故按照正序遍历即可解决问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此，这个问题已经圆满解决了，但是还是有一些小瑕疵：对于dp数组的定义。在本问题中，将dp数组定义为nums[0…i]的最长子序列长度其实并不太合适，但是这样定义又是我自己的第一反应，这也是我在第二次解题时仍然遇到困难的主要原因。事后我在查看题解时发现了一种更加合理的定义方式：dp[i]的含义时以nums[i] 结尾的最长子序列长度。由于这个定义明确了每个最长子序列的末尾，很巧妙的契合了我们的“选择”，即到底接在哪个最长子序列的末尾，那么解决接下来的问题就势如破竹了。</p><p>从这里也可以看出dp数组的定义真的对于动态规划问题的解决十分的关键。可以说一个好的dp数组的定义是解决动态规划问题的关键所在。dp数组定义的好，推导状态转移方程也是水到渠成的事情。但是这种在我看来比较巧妙地dp数组的定义方式，只能靠不断积累（智商有限）。</p><p>下面附上完整代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>int<span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>       dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token comment" spellcheck="true"># 初始化</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划复习小结</title>
      <link href="/posts/60634.html"/>
      <url>/posts/60634.html</url>
      
        <content type="html"><![CDATA[<ol><li><h1 id="动态规划复习小结"><a href="#动态规划复习小结" class="headerlink" title="动态规划复习小结"></a>动态规划复习小结</h1><p>最早系统的学习动态规划还是在大二算法课上，当时因为仓促应付考试的原因，学的也是一些皮毛，并没有真正理解动态规划的精髓所在。后来才发现，动态规划在算法方面的应用实在是太多了，很多hard题目都是动态规划相关。动态规划非常的灵活，可以说没有任何套路可循。给你一个动态规划的问题，能否很好的解决出来真的就是靠感觉和经验。</p><p>在最近做leetcode期间，我再一次被动态规划相关问题所困扰。因此便想好好联系一下相关题目，同时也找了很多网上的教程学习参考。在此对这一阶段学习的内容做一个小小的复习。</p><h2 id="动态规划问题的特点"><a href="#动态规划问题的特点" class="headerlink" title="动态规划问题的特点"></a>动态规划问题的特点</h2><p>我们在解决问题的时候，很少会告诉你这就是一个动态规划的问题，更多的是直接让你去解决。那么如何去判断一个问题是不是动态规划问题呢？</p><p>其实也很简单，动态规划的目的，或者说作用就是用已有结果计算当前问题，已达到避免重复计算的目的。在做了一些题目以后发现，动态规划问题一般都是求最值的问题。当你拿到一个问题后，可以先尝试着用暴力方法来解决这个问题，找到问题的暴力解之后， 仔细分析这个解法，如果出现了很多重复计算的子问题，并且子问题之间互不相关，那么这就是动态规划的问题了。再者，还有一个办法就是对于原问题dp[i] [j]，有不止一条路径可以到达dp[i-1] [j-1]，一旦有一条路径是重复的，就是说明存在重复的子问题了，也就是说这是一个动态规划的问题了。</p><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>刚才提到的很多重复计算的子问题，也不是所有的这样的情况都是动态规划问题。动态规划中提到的子问题称为  <strong>最优子结构</strong> ,其实就是子问题之间只要没有直接关联，不会相互影响就是最优子结构，只要带入几个具体实例尝试一下便知道了。<br>但是不是所有问题都会有最优子结构，这不是说这个问题就一定不能用动态规划的思路来解决，而是需要对子问题进行优化和等价转化。通过将不是最优子结构的问题转化为另一个等价的问题来构造最优子结构</p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>虽然说动态规划问题非常灵活，这是指动态规划问题的dp table的设计非常灵活，但是总的解决问题的方向还是有的。在参考了很多思想之后，我发现了一种理解起来比较好的解决问题的思路。</p><p>首先明确一个概念：动态规划的核心还是穷举。其实在计算机中，所有的解决问题的方法都是穷举，只是问题的关键在于如何更加聪明的穷举，这是很多算法研究的方向。在动态规划中，穷举是通过<strong>dp table</strong>+<strong>状态转移方程</strong> 完成的。在动态规划的问题中，这两点各占问题的50%。</p><p>如果要将动态规划问题的解决路线模式化，我认为如下模式比较合适：</p><ol><li>明确问题的状态</li><li>确定dp tatble的含义</li><li>明确当前的选择</li><li>写出状态转移方程</li><li>初始化base case</li></ol><h3 id="1-明确问题的状态"><a href="#1-明确问题的状态" class="headerlink" title="1. 明确问题的状态"></a>1. 明确问题的状态</h3><p>何为问题的状态？这个定义很抽象。状态就是问题中的变化的量，或者可以类比为自动机中的状态的感觉。</p><h3 id="2-确定dp-table的含义"><a href="#2-确定dp-table的含义" class="headerlink" title="2. 确定dp table的含义"></a>2. 确定dp table的含义</h3><p>dp table是解决动态规划问题的两个关键之一。dp table通常是一维，二维数组或者一个字典。关于如何定义dp table，我认为没有什么技巧，只能通过不断的积累经验。下面记录几个最近常用的定义方式（后面不断补充）：</p><ul><li>字符串相关的问题：<br>一般是定义一个二维数组，dp[i][j] 为s1[0…i] 到s2[0…j]的最大值（示具体情况而定）<br>定义完dp table，动态规划问题就解决了一半，最终答案一般为dp[n]。</li></ul><h3 id="3-明确当前选择"><a href="#3-明确当前选择" class="headerlink" title="3.明确当前选择"></a>3.明确当前选择</h3><p>什么又是选择？选择是在当前状态下，可以做出的改变，是状态转移方程的基础。动态规划问题就是在当前状态下，在可选的选择中择优选择。越来越发现动态规划问题和有限状态机有一定的相似之处：<img src="1.png" alt=""><br>这个图明确了状态和选择之间的关系，状态转移方程只不过是将这个图用数学方式描述出来，仅此而已。</p><h3 id="4-写出状态转移方程"><a href="#4-写出状态转移方程" class="headerlink" title="4.写出状态转移方程"></a>4.写出状态转移方程</h3><p>有了上面的工作做铺垫，写出状态方程则是水到渠成的事情。其实前面4步没有特别严格的顺序。通常情况下不能直接看出问题的状态转移方程，可以先写出问题的暴力解法，然后一步步的从中分析出问题的状态方程。<br>另一个角度，在定义了dp table后，可以考虑一下如何推导出dp[i] [j]，这也就是状态转移方程的另一种表现形式，也就是数学归纳法。</p><h3 id="5-初始化base-case"><a href="#5-初始化base-case" class="headerlink" title="5. 初始化base case"></a>5. 初始化base case</h3><p>可以说这一步是整个动态规划解题过程中最简单的一步了，但也是同样重要的一步。这一步只需要根据dp table的定义，确定base case即可</p><h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><h3 id="dp数组的遍历顺序问题"><a href="#dp数组的遍历顺序问题" class="headerlink" title="dp数组的遍历顺序问题"></a>dp数组的遍历顺序问题</h3><p>如何遍历一个dp数组？到底是正着遍历还是反着遍历？其实只要遵循一个原则：只要能够从base case根据状态转移方程推导到最终答案即可。<br>再次记录一下斜着遍历数组的实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> p <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> q <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>        i <span class="token operator">=</span> q        j <span class="token operator">=</span> p<span class="token operator">+</span>q        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前我对动态规划的理解就是这样一个程度，后续随着不断的学习会继续补充，也会选择几个个人非常喜欢和经典的题目进行解析。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/posts/59448.html"/>
      <url>/posts/59448.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>​    疫情期间实在没有什么事情可干，更没办法静下心来学习，只好翻翻自己的toDo-list， 终于决定把自己鸽了大半年的博客搭起来。</p><p>​    最开始搭博客只是因为在学习django，想自搭一个博客练练手。后来发现搭一个博客要简单也简单，要难也难。最初使用django的时候，发现它太过于臃肿，对于我当时的 需求来说有点“杀鸡焉用宰牛刀”的感觉。于是我又发现了更加轻量化的框架-flask，然后简单学习了一下，发现很契合我的需求，并且在我看来，flask更加符合pythonic，这样后台框架就确定下来了。然后是前端框架，对于我这种对前端一窍不通并且看到js代码就一阵头疼的人来说，只能是找一个很成熟的框架直接用这样子。在这个原则下以及咨询了几个大佬之后，我发现了bootstrap。最开始，我把它当作我blog前端开发的救星，后来随着用的越来越多，也是在查找相关资料时看的相关博客越来越多，我发现很少有blog用的是bootstrap风格的，大多都比bootstrap更加简洁（逼格），于是开始嫌弃bootstrap。至此我的blog开发就停滞不前了，让我自己设计前端界面，可能还不如bootstrap，对于我这种强迫症来说，是不能接受自己的博客是纯html或者只有bootstrap风格的。于是，在更加简洁（逼格）的静态blog和自建动态blog之间，我选择向前者妥协（：，于是便有了现在这个blog，基于hexo-matery + github pages 的静态blog，虽然感觉有点差强人意，但是还算够用（至少看起来比bootstrap强）。在查相关资料期间，我也发现了几个很有意思的blog，也算小有收获吧。也许在以后的某一天，我会又突然脑热，下定决心好好学一学前端（有生之年），自己完完全全搭一个blog。那么在这之前，就先在这里凑活一下啦，毕竟比起那些花里胡哨的外观，内容才是重点。</p><p>​    在这里我会不定时记录一些小随笔，一些学习记录，或者只是记录一个bug解决方案，总之就是记录一些有意义的或者没意义的事情吧。</p><p>​    在这里顺手记录一个刚发现的hexo-matery的小坑，每一篇blog的cover图片根目录在\themes\matery\source，这也是困扰了我好久才找到，甚至去原项目提了一个issue。</p><p>test</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
